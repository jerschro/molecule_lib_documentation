{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#versionmodule-doc-string","title":"Version/Module doc-string","text":""},{"location":"#molecule_lib.__version__","title":"<code>__version__ = '4-4-2024-1'</code>  <code>module-attribute</code>","text":""},{"location":"#molecule_lib.__version_tuple__","title":"<code>__version_tuple__ = (4, 4, 2024, 1)</code>  <code>module-attribute</code>","text":""},{"location":"#welcome-to-molecule_lib-documentation","title":"Welcome to molecule_lib Documentation","text":"<p>This is a library dedicated to manipulating and creating molecular structures using python for theoretical chemistry. Any feedback or bugs please email jerschro@ttu.edu or jeremynschroeder@gmail.com Created by Jeremy Schroeder \u00a9 2024</p>"},{"location":"#to-install-molecule_lib","title":"To install molecule_lib","text":"<ul> <li>Copy source code into conda/lib/site-packages/molecule_lib or conda/envs/lib/site-packages/molecule_lib</li> <li>Have source code in folder molecule_lib located in repository where code you are importing molecule_lib</li> <li>(Not currently uploaded) <code>pip install molecule_lib</code> </li> <li>(Not currently uploaded) <code>conda install molecule_lib --channel conda-forge</code> </li> </ul>"},{"location":"#to-import-molecule_lib-into-python-code","title":"To import molecule_lib into python code","text":"<p><code>python</code>  from molecule_lib import *</p>"},{"location":"read_functions/","title":"Input of molecule_lib","text":""},{"location":"read_functions/#molecule_lib.read_vasp","title":"<code>molecule_lib.read_vasp(filepath, extralines=False)</code>","text":"<p>Reads .vasp or POSCAR file and returns ABCMolecule instance.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>Filename (if in current working directory) or absolute path or os.path.join(os.getcwd(),'filename.xyz')</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, if there are extra lines in the file, function will not return XYZMolecule instance. It is quote 'strict' on extra lines if True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul> Notes <p>Add selective logic, maybe add a bool to turn it on and off or add it if it doesn't have it.</p>"},{"location":"read_functions/#molecule_lib.read_turbomole","title":"<code>molecule_lib.read_turbomole(filepath)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>XYZMolecule</code>         \u2013          <p>description</p> </li> </ul>"},{"location":"read_functions/#molecule_lib.read_xyz","title":"<code>molecule_lib.read_xyz(filepath, extralines=False)</code>","text":"<p>Reads .xyz file and returns XYZMolecule instance.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>Filename (if in current working directory) or absolute path or os.path.join(os.getcwd(),'filename.xyz')</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, if there are extra lines in the file, function will not return XYZMolecule instance. It is quote 'strict' on extra lines if True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>XYZMolecule</code>         \u2013          <p>description</p> </li> </ul>"},{"location":"read_functions/#molecule_lib.read_xsf","title":"<code>molecule_lib.read_xsf(filepath)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule | XYZMolecule</code>         \u2013          <p>description</p> </li> </ul> Notes <p>Need to ensure keywords for xyzmolecule is only ATOMS and keyword for abcmolecule is \"primvec\" and \"primcoord\"</p>"},{"location":"read_functions/#molecule_lib.read_siesta","title":"<code>molecule_lib.read_siesta(filepath)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul>"},{"location":"reference/","title":"Reference Documentation","text":""},{"location":"reference/#globals-docstrings","title":"Globals Docstrings","text":""},{"location":"reference/#molecule_lib.GLOBALS_DOCSTRINGS","title":"<code>molecule_lib.GLOBALS_DOCSTRINGS</code>","text":"<p>Attributes:</p> <ul> <li> <code>ACCEPTED_ELEMENTS</code>         \u2013          <p>description</p> </li> <li> <code>Lx</code>         \u2013          <p>description</p> </li> <li> <code>Fx</code>         \u2013          <p>description</p> </li> <li> <code>La</code>         \u2013          <p>description</p> </li> <li> <code>Fa</code>         \u2013          <p>description</p> </li> <li> <code>Sa</code>         \u2013          <p>description</p> </li> <li> <code>Lc</code>         \u2013          <p>description</p> </li> <li> <code>Fc</code>         \u2013          <p>description</p> </li> <li> <code>UC_90_ANGLE_MAX</code>         \u2013          <p>description</p> </li> <li> <code>UC_90_ANGLE_MIN</code>         \u2013          <p>description</p> </li> <li> <code>MolIndex</code>         \u2013          <p>description</p> </li> <li> <code>MOLAR_MASS</code>         \u2013          <p>description</p> </li> </ul>"},{"location":"reference/#math-functions","title":"Math functions","text":""},{"location":"reference/#molecule_lib.csc","title":"<code>molecule_lib.csc(x)</code>","text":"<p>Return the cosecant of x (measured in radians).</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def csc(x: float) -&gt; float:  # used in molecule.py\n    \"\"\"Return the cosecant of x (measured in radians).\"\"\"\n    return 1 / sin(x)\n</code></pre>"},{"location":"reference/#molecule_lib.sec","title":"<code>molecule_lib.sec(x)</code>","text":"<p>Return the secant of x (measured in radians).</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def sec(x: float) -&gt; float:  # used in molecule.py\n    \"\"\"Return the secant of x (measured in radians).\"\"\"\n    return 1 / cos(x)\n</code></pre>"},{"location":"reference/#molecule_lib.cot","title":"<code>molecule_lib.cot(x)</code>","text":"<p>Return the cotangent of x (measured in radians).</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def cot(x: float) -&gt; float:  # used in molecule.py\n    \"\"\"Return the cotangent of x (measured in radians).\"\"\"\n    return 1 / tan(x)\n</code></pre>"},{"location":"reference/#molecule_lib._isfloatstr","title":"<code>molecule_lib._isfloatstr(item)</code>","text":"<p>Return True if item is float string, False otherwise.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def _isfloatstr(item: str) -&gt; bool:\n    \"\"\"Return True if item is float string, False otherwise.\"\"\"\n    if type(item) != str:\n        return False\n    if item.find(\".\") != -1 and item.find(\".\", item.find(\".\") + 1) != -1:\n        return False\n    return item.replace(\".\", \"\").replace(\"-\", \"\").isdecimal()\n</code></pre>"},{"location":"reference/#abc-unitcell-molecule-section","title":"ABC (Unitcell) Molecule Section","text":""},{"location":"reference/#molecule_lib.ABCCoord","title":"<code>molecule_lib.ABCCoord</code>","text":"<p>Dataclass for atomic coordinates for use in ABCMolecule class.</p> <p>Parameters:</p> <ul> <li> <code>sp</code>             (<code>str</code>)         \u2013          <p>Species of atom.</p> </li> <li> <code>a</code>             (<code>float</code>)         \u2013          <p>a or x coordinate position of atom.</p> </li> <li> <code>b</code>             (<code>float</code>)         \u2013          <p>b or y coordinate position of atom.</p> </li> <li> <code>c</code>             (<code>float</code>)         \u2013          <p>c or z coordinate position of atom.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCCoord</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>class ABCCoord:\n    \"\"\"Dataclass for atomic coordinates for use in ABCMolecule class.\n\n    Parameters\n    ----------\n    sp : str\n        Species of atom.\n    a : float\n        a or x coordinate position of atom.\n    b : float\n        b or y coordinate position of atom.\n    c : float\n        c or z coordinate position of atom.\n\n    Returns\n    -------\n    ABCCoord\n        _description_\n    \"\"\"\n\n    def __init__(self, sp: str, a: float, b: float, c: float) -&gt; None:\n        if sp not in ACCEPTED_ELEMENTS:\n            raise ValueError(f\"ABCCoord.__init__() required postional argument 'sp' is not an accepted species string\") # yapf: disable\n        if type(a) not in [int, float]:\n            raise ValueError(f\"ABCCoord.__init__() required positional argument 'x' is not a number\") # yapf: disable\n        if type(b) not in [int, float]:\n            raise ValueError(f\"ABCCoord.__init__() required positional argument 'y' is not a number\") # yapf: disable\n        if type(c) not in [int, float]:\n            raise ValueError(f\"ABCCoord.__init__() required positional argument 'z' is not a number\") # yapf: disable\n        self.sp = sp\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self) -&gt; str:\n        # \"\"\"\n        # Notes\n        # -----\n        # when you are in kernel and run object with enter\n        # \"\"\"\n        return f\"ABCCoord(sp='{self.sp}', x={self.a}, y={self.b}, z={self.c})\"\n\n    def __str__(self) -&gt; str:\n        # \"\"\"\n        # Notes\n        # -----\n        # by using str() or print()\n        # also might need to create XYZCoord.line() method because this return was used in editor i think\n        # return f\"{self.sp:&gt;4} {self.x:&gt;{Lc}.{Fc}f}{self.y:&gt;{Lc}.{Fc}f}{self.z:&gt;{Lc}.{Fc}f}\"\n        # \"\"\"\n        return f\"ABCCoord(sp='{self.sp}', x={self.a}, y={self.b}, z={self.c})\"\n\n    def __len__(self) -&gt; int:\n        # \"\"\"\n        # Notes\n        # -----\n        # needed for something... i think it was indexing but not 100% positive\n        # \"\"\"\n        return 1\n\n    def __getitem__(self, index: int) -&gt; float:\n        if index == 1:\n            return self.a\n        elif index == 2:\n            return self.b\n        elif index == 3:\n            return self.c\n        else:\n            raise IndexError(\"ABCCoord.__getitem__() Index out of list.\")\n\n    def line(self) -&gt; str:\n        return f\"{self.sp:&gt;4} {self.a:&gt;{Lc}.{Fc}f}{self.b:&gt;{Lc}.{Fc}f}{self.c:&gt;{Lc}.{Fc}f}\"\n</code></pre>"},{"location":"reference/#molecule_lib.ABCCoord.line","title":"<code>line()</code>","text":"Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def line(self) -&gt; str:\n    return f\"{self.sp:&gt;4} {self.a:&gt;{Lc}.{Fc}f}{self.b:&gt;{Lc}.{Fc}f}{self.c:&gt;{Lc}.{Fc}f}\"\n</code></pre>"},{"location":"reference/#molecule_lib.LatticeMatrix","title":"<code>molecule_lib.LatticeMatrix</code>","text":"<p>Dataclass for ABCMolecule Class.</p> <p>Parameters:</p> <ul> <li> <code>constant</code>             (<code>float</code>)         \u2013          <p>description</p> </li> <li> <code>vector_1</code>             (<code>Union[float, float, float]</code>)         \u2013          <p>description</p> </li> <li> <code>vector_2</code>             (<code>Union[float, float, float]</code>)         \u2013          <p>description</p> </li> <li> <code>vector_3</code>             (<code>Union[float, float, float]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LatticeMatrix</code>         \u2013          <p>description</p> </li> </ul> Notes <p>Other Attributes Generated:     a: float     b: float     c: float     alp: float     bet: float     gam: float     volume: float</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>class LatticeMatrix:\n    \"\"\"Dataclass for ABCMolecule Class.\n\n    Parameters\n    ----------\n    constant : float\n        __description__\n    vector_1 : Union[float,float,float]\n        __description__\n    vector_2 : Union[float,float,float]\n        __description__\n    vector_3 : Union[float,float,float]\n        __description__\n\n    Returns\n    -------\n    LatticeMatrix\n        __description__\n\n    Notes\n    -----\n    Other Attributes Generated:\n        a: float\n        b: float\n        c: float\n        alp: float\n        bet: float\n        gam: float\n        volume: float\n    \"\"\"\n    def __init__(self, constant: float, vector_1: list[float], vector_2: list[float], vector_3: list[float]) -&gt; None:\n        if type(constant) not in [int, float]:\n            raise ValueError(\"LatticeMatrix.__init__() required positional argument 'constant' is not a number\") # yapf: disable\n        for name, vector in zip([\"vector_1\", \"vector_2\", \"vector_3\"],[vector_1, vector_2, vector_3]):\n            if not isinstance(vector, list) and not isinstance(vector, tuple):\n                raise ValueError(f\"LatticeMatrix.__init__() required positional argument '{name}' is not a list\") # yapf: disable\n            if len(vector) != 3:\n                raise ValueError(f\"LatticeMatrix.__init__() required positional argument '{name}' is not a list of length 3\") # yapf: disable\n            for index in range(3):\n                if not isinstance(vector[index], int) and not isinstance(vector[index], float):\n                    raise ValueError(f\"LatticeMatrix.__init__() required positional argument '{name}' index {index} is not a number\") # yapf: disable\n        self.constant: float = constant\n        self.vector_1: list[float] = vector_1\n        self.vector_2: list[float] = vector_2\n        self.vector_3: list[float] = vector_3\n        self.a: float = (self.vector_1[0]**2 + self.vector_1[1]**2 +\n                         self.vector_1[2]**2)**(1 / 2)\n        self.b: float = (self.vector_2[0]**2 + self.vector_2[1]**2 +\n                         self.vector_2[2]**2)**(1 / 2)\n        self.c: float = (self.vector_3[0]**2 + self.vector_3[1]**2 +\n                         self.vector_3[2]**2)**(1 / 2)\n        self.alp: float = np.arccos(\n            np.dot(np.array(self.vector_2), np.array(self.vector_3)) /\n            (self.b * self.c))\n        self.bet: float = np.arccos(\n            np.dot(np.array(self.vector_1), np.array(self.vector_3)) /\n            (self.a * self.c))\n        self.gam: float = np.arccos(\n            np.dot(np.array(self.vector_1), np.array(self.vector_2)) /\n            (self.a * self.b))\n        self.volume: float = (\n            self.a * self.b * self.c *\n            (1 + 2 * np.cos(self.alp) * np.cos(self.bet) * np.cos(self.gam) -\n             np.cos(self.alp)**2 - np.cos(self.bet)**2 - np.cos(self.gam)**2)\n            **(1 / 2))\n\n\n    def __repr__(self) -&gt; str:\n        # \"\"\"\n        # Notes\n        # -----\n        # when you are in kernel and run object with enter\n        # \"\"\"\n        return f\"LatticeMatrix(constant={self.constant}, vector_1={self.vector_1}, vector_2={self.vector_2}, vector_3={self.vector_3})\"\n\n    def __str__(self) -&gt; str:\n        # \"\"\"\n        # Notes\n        # -----\n        # by using str() or print()\n        # also might need to create XYZCoord.line() method because this return was used in editor i think\n        # return f\"{self.sp:&gt;4} {self.x:&gt;{Lc}.{Fc}f}{self.y:&gt;{Lc}.{Fc}f}{self.z:&gt;{Lc}.{Fc}f}\"\n        # \"\"\"\n        return f\"LatticeMatrix(constant={self.constant}, vector_1={self.vector_1}, vector_2={self.vector_2}, vector_3={self.vector_3})\"\n\n    def getabc(self) -&gt; tuple[float, float, float]:\n        \"\"\"Returns sidelengths (a,b,c) of unitcell.\"\"\"\n        return self.a, self.b, self.c\n\n    def getanglesdeg(self) -&gt; tuple[float, float, float]:\n        \"\"\"Returns (alpha, beta, gamma) of unitcell in degrees.\"\"\"\n        return (self.alp * (180 / np.pi), self.bet * (180 / np.pi),\n                self.gam * (180 / np.pi))\n\n    def getanglesrad(self) -&gt; tuple[float, float, float]:\n        \"\"\"Returns (alpha, beta, gamma) of unitcell in radians.\"\"\"\n        return self.alp, self.bet, self.gam\n</code></pre>"},{"location":"reference/#molecule_lib.LatticeMatrix.getabc","title":"<code>getabc()</code>","text":"<p>Returns sidelengths (a,b,c) of unitcell.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def getabc(self) -&gt; tuple[float, float, float]:\n    \"\"\"Returns sidelengths (a,b,c) of unitcell.\"\"\"\n    return self.a, self.b, self.c\n</code></pre>"},{"location":"reference/#molecule_lib.LatticeMatrix.getanglesdeg","title":"<code>getanglesdeg()</code>","text":"<p>Returns (alpha, beta, gamma) of unitcell in degrees.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def getanglesdeg(self) -&gt; tuple[float, float, float]:\n    \"\"\"Returns (alpha, beta, gamma) of unitcell in degrees.\"\"\"\n    return (self.alp * (180 / np.pi), self.bet * (180 / np.pi),\n            self.gam * (180 / np.pi))\n</code></pre>"},{"location":"reference/#molecule_lib.LatticeMatrix.getanglesrad","title":"<code>getanglesrad()</code>","text":"<p>Returns (alpha, beta, gamma) of unitcell in radians.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def getanglesrad(self) -&gt; tuple[float, float, float]:\n    \"\"\"Returns (alpha, beta, gamma) of unitcell in radians.\"\"\"\n    return self.alp, self.bet, self.gam\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule","title":"<code>molecule_lib.ABCMolecule</code>","text":"<p>Class for ABC molecule object.</p> <p>Parameters:</p> <ul> <li> <code>unitcell</code>             (<code>LatticeMatrix</code>)         \u2013          <p>Instance of LatticeMatrix dataclass needed for ABCMolecule class.</p> </li> <li> <code>atoms</code>             (<code>list[ABCCoord]</code>)         \u2013          <p>description</p> </li> <li> <code>positional</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, given ABCCoords are positional coordinates. If False, given ABCCoords are cartesian coordinates in Angstroms.</p> </li> <li> <code>comment_line</code>             (<code>str</code>, default:                 <code>is \" \"</code> )         \u2013          <p>description</p> </li> <li> <code>filetype</code>             (<code>str</code>, default:                 <code>'unitcell'</code> )         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>class ABCMolecule:\n    \"\"\"Class for ABC molecule object.\n\n    Parameters\n    ----------\n    unitcell : LatticeMatrix\n        Instance of LatticeMatrix dataclass needed for ABCMolecule class.\n    atoms : list[ABCCoord]\n        _description_\n    positional : bool, default True\n        If True, given ABCCoords are positional coordinates. If False, given ABCCoords are cartesian coordinates in Angstroms.\n    comment_line : str, default is \" \"\n        _description_\n    filetype: str\n        __description__\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n\n    def __init__(self,\n                 unitcell: LatticeMatrix,\n                 positional: bool,\n                 atoms: list[ABCCoord],\n                 comment_line: str = \" \",\n                 frozen_atoms: list[list[str]] = [[\"\"]],\n                 filetype: str = \"unitcell\") -&gt; None:\n        for n, item in enumerate(atoms):\n            if not isinstance(item, ABCCoord):\n                raise ValueError(f\"ABCMolecule.__init__() index {n} of atoms is not type ABCCoord; item = {item}\") # yapf: disable\n        self.unitcell = unitcell\n        self.positional = positional\n        self.atoms: list[ABCCoord] = atoms\n        self.comment_line: str = str(comment_line)\n        self.frozen_atoms: list[list[str]] = frozen_atoms\n        self.filetype: str = str(filetype)\n        self.__post_init__()\n\n    def __post_init__(self):\n        \"\"\"Creates other instance variables from initial variables given.\"\"\"\n        self.coord_type = ABCCoord\n        for ele in self.atoms:\n            if isinstance(ele, ABCCoord) is False:\n                raise Exception(f\"Atoms input not all type ABCCoord\")\n        self.species_line: list[str] = list()\n        self.species_amount: list[str] = list()\n        _ = \"__\"\n        for atom in self.atoms:\n            if atom.sp == _:\n                self.species_amount[-1] = str(1 + int(self.species_amount[-1]))\n            else:\n                self.species_line.append(atom.sp)\n                self.species_amount.append(\"1\")\n                _ = atom.sp\n        self.total = sum([int(num) for num in self.species_amount])\n\n    def __str__(self) -&gt; str:\n        return f\"ABCMolecule(unitcell={self.unitcell}, atoms={self.atoms}, positional={self.positional}, comment_line='{self.comment_line}', filetype='{self.filetype}')\"\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    def __add__(self, item: ABCMolecule) -&gt; ABCMolecule:\n        if isinstance(item, ABCMolecule):\n            new_coords = item.atoms\n        else:\n            raise ValueError(\"ABCMolecule.__add__() can only add type ABCMolecule\") # yapf: disable\n        return self.append(new_coords=new_coords,\n                           positional=True if not self.positional else False)\n\n    def __len__(self):\n        return len(self.atoms)\n\n    def __getitem__(self, index: MolIndex) -&gt; ABCMolecule:\n        \"\"\"\n        Notes\n        -----\n        index type is int | str | list[int] | list[str]\n        \"\"\"\n        if type(index) in [int, str]:\n            index = str(index)\n            if index.replace(\"-\", \"\").isdecimal():\n                if -len(self.atoms) &lt;= int(index) &lt;= -1:\n                    return ABCMolecule(unitcell=self.unitcell,\n                                       positional=self.positional,\n                                       atoms=[self.atoms[int(index)]],\n                                       comment_line=self.comment_line,\n                                       filetype=self.filetype)\n                elif len(self.atoms) &gt;= int(index) &gt;= 1:\n                    return ABCMolecule(unitcell=self.unitcell,\n                                       positional=self.positional,\n                                       atoms=[self.atoms[int(index) - 1]],\n                                       comment_line=self.comment_line,\n                                       filetype=self.filetype)\n                else:\n                    raise IndexError(f\"ABCMolecule.__getitem__() int is out of range of len(self.atoms) or is zero\") # yapf: disable\n            elif index in self.species_line:\n                return ABCMolecule(\n                    unitcell=self.unitcell,\n                    positional=self.positional,\n                    atoms=[item for item in self.atoms if item.sp == index],\n                    comment_line=self.comment_line,\n                    filetype=self.filetype)\n            else:\n                return ABCMolecule(\n                    unitcell=self.unitcell,\n                    positional=self.positional,\n                    atoms=[self.atoms[self._get_molden_index(index)]],\n                    comment_line=self.comment_line,\n                    filetype=self.filetype)\n        elif type(index) is list:\n            return_atoms: list[ABCCoord] = list()\n            for item in [str(ele) for ele in index]:\n                if item.replace(\"-\", \"\").isdecimal():\n                    if -len(self.atoms) &lt;= int(item) &lt;= -1:\n                        return_atoms.append(self.atoms[int(item)])\n                    elif len(self.atoms) &gt;= int(item) &gt;= 1:\n                        return_atoms.append(self.atoms[int(item) - 1])\n                    else:\n                        raise IndexError(f\"ABCMolecule.__getitem__() int is out of range of len(self.atoms)\") # yapf: disable\n                elif item in self.species_line:\n                    return_atoms.extend(\n                        [ele for ele in self.atoms if ele.sp == item])\n                else:\n                    return_atoms.append(\n                        self.atoms[self._get_molden_index(item)])\n            return ABCMolecule(unitcell=self.unitcell,\n                               positional=self.positional,\n                               atoms=return_atoms,\n                               comment_line=self.comment_line,\n                               filetype=self.filetype)\n        else:\n            raise IndexError(f\"ABCMolecule.__getitem__() not valid index\")\n\n    def _get_molden_index(self, index: MolIndex) -&gt; int:\n        if type(index) != str:\n            raise IndexError(\"ABCMolecule._get_molden_index() index type not correct\") # yapf: disable\n        _n1 = \"\"\n        _a1 = \"\"\n        for item in index[::-1]:\n            if item.isdecimal():\n                _n1 += item\n            else:\n                _a1 += item\n        _n2 = _n1[::-1]\n        if _n2 == \"\":\n            raise IndexError(\"ABCMolecule._get_molden_index() no # after\")\n        _a2 = _a1[::-1]\n        if index == _a2 + _n2:\n            _n3 = int(_n2)\n            if _a2 not in self.species_line:\n                raise IndexError(\"ABCMolecule._get_molden_index() Sp not in self.speciesline\") # yapf: disable\n            if int(self.species_amount[self.species_line.index(\n                    _a2)]) &gt;= _n3 &gt;= 1:\n                return self.atoms.index(\n                    [item for item in self.atoms if item.sp == _a2][_n3 - 1])\n            else:\n                raise IndexError(\"ABCMolecule._get_molden_index() # is too large or zero\") # yapf: disable\n        else:\n            raise IndexError(\"ABCMolecule._get_molden_index() Sp# out of order\") # yapf: disable\n\n    def __setitem__(self, index: int | str, new_item: ABCCoord) -&gt; None:\n        if type(index) not in [int, str]:\n            raise ValueError(\"ABCMolecule.__setitem__() index must be of type int or str\") # yapf: disable\n        if isinstance(new_item, ABCCoord):\n            self.atoms[self.atoms.index(\n                self.__getitem__(index).atoms[0])] = new_item\n            self.__post_init__()\n        else:\n            raise ValueError(\"ABCMolecule.__setitem__() Value assignment must be type XYZCoord\") # yapf: disable\n\n    def add_coords(self,\n                   molecule: ABCMolecule | XYZMolecule,\n                   axis: str | int,\n                   absorbent_reference: str | ABCCoord,\n                   surface_reference: str | ABCCoord,\n                   dist: float,\n                   inplace: bool = False) -&gt; ABCMolecule:\n        \"\"\"Add a new Molecule object to the current ABCMolecule object very precisely.\n\n        Parameters\n        ----------\n        molecule : ABCMolecule or XYZMolecule\n            _description_\n        axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n            Placement of new molecule will be in direction of axis.\n        absorbent_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n            _description_\n        surface_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n            _description_\n        dist : float\n            sign of float determines what direction the new molecule is placed.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        ABCMolecule\n            ABCMolecule with new atoms added.\n\n        Notes\n        ------\n        Need to add CoordType logic.\n        Need to add ABCMolecule logic.\n        NEED TO ADD absorbent/surface reference can of type coord also probably need coord protocol\n        NEED TO ADD LOGIC FOR CONVERTING TO DIFFERENT ATOM TYPES\n        operation happens in cartesian coordinates and then the new coords are converted back to positional\n        need to ensure operation only happens in a trigonal unit cell until i find the generic unitcell formula\n        \"\"\"\n        if axis not in [\"x\", \"y\", \"z\"] and axis not in [0, 1, 2]:\n            raise ValueError(f\"XYZMolecule.add_coords() required argument 'angle' is not 'x' or 'y' or 'z' or 1 or 2 or 3 \") # yapf: disable\n        match axis:\n            case \"x\":\n                axis_int = 0\n            case \"y\":\n                axis_int = 1\n            case \"z\":\n                axis_int = 2\n            case _:\n                axis_int = int(axis)\n        if isinstance(molecule, ABCMolecule):\n            if molecule.positional:\n                molecule = molecule.convert()\n        elif isinstance(molecule, XYZMolecule):\n            pass\n        else:\n            raise ValueError(\"ABCMolecule.add_coords() required argument 'molecule' not correct type\") # yapf: disable\n        # needed to not append to memory and return only changed object\n        combined_atoms = copy.copy(self.atoms)\n        # need convert bc operation happens in cartesian coords\n        sur_centroids = self.convert().get_centroid()\n        sur_mod = [sur_centroids[0], sur_centroids[1], sur_centroids[2]]\n        x_import_centroid, y_import_centroid, z_import_centroid = molecule.get_centroid(\n        )\n        abs_centroids = [\n            x_import_centroid, y_import_centroid, z_import_centroid\n        ]\n        x_import_list = [float(coord[1]) for coord in molecule.atoms]\n        y_import_list = [float(coord[2]) for coord in molecule.atoms]\n        z_import_list = [float(coord[3]) for coord in molecule.atoms]\n        abs_lists = (x_import_list, y_import_list, z_import_list)\n        atom_list = self.convert().atoms if self.positional else self.atoms\n        x_curr_list = [float(coord[1]) for coord in atom_list]\n        y_curr_list = [float(coord[2]) for coord in atom_list]\n        z_curr_list = [float(coord[3]) for coord in atom_list]\n        sur_lists = (x_curr_list, y_curr_list, z_curr_list)\n        # finding absorbent values\n        if absorbent_reference == \"Centroid\":\n            abs_mod = abs_centroids\n        elif absorbent_reference == \"Top\" or absorbent_reference == \"Bottom\":\n            abs_mod = abs_centroids\n            if absorbent_reference == \"Top\":\n                sort_func = max\n            else:  # if absorbent_reference == \"Bottom\":\n                sort_func = min\n            abs_mod[axis_int] = sort_func(abs_lists[axis_int])\n        else:\n            abs_mod = [0.0, 0.0, 0.0]\n        # finding surface values now\n        if not isinstance(surface_reference, ABCCoord) and not isinstance(\n                surface_reference, str):\n            raise ValueError(\"ABCMolecule.add_coords() required argument 'surface_reference' is not type str or ABCCoord.\") # yapf: disable\n        if isinstance(surface_reference, ABCCoord):\n            pass\n        elif surface_reference == \"Centroid\":\n            sur_mod = sur_centroids\n        elif surface_reference == \"(0.5,0.5,0.5)\":\n            sur_mod = [0.5, 0.5, 0.5]\n        elif surface_reference == \"Top\" or surface_reference == \"Bottom\":\n            if surface_reference == \"Top\":\n                sort_func = max\n            # if surface_reference == ABSORBENT_OPTIONS['starting_surface_list'][1]:\n            else:\n                sort_func = min\n            sur_mod[axis_int] = sort_func(sur_lists[axis_int])\n        elif \"Most positive \" in surface_reference or \"Most negative\" in surface_reference:\n            species = surface_reference[14:]\n            if \"Most positive \" in surface_reference:\n                sort_func = max\n            else:  # if \"Most negative\" in surface_reference:\n                sort_func = min\n            species_import_list = [\n                float(coord[axis_int + 1]) for coord in self.atoms\n                if coord.sp == species\n            ]\n            sur_mod[axis_int] = sort_func(species_import_list)\n        else:  # necessary for add atom\n            sur_mod = [0, 0, 0]  # if surface_reference == 'origin'\n        # math for finding displacement distanceance\n        distance = [0.0, 0.0, 0.0]\n        distance[axis_int] = dist\n        # print(f'{sur_mod = }')\n        # print(f'{abs_mod = }')\n        x_mod = sur_mod[0] - abs_mod[0] + distance[0]\n        y_mod = sur_mod[1] - abs_mod[1] + distance[1]\n        z_mod = sur_mod[2] - abs_mod[2] + distance[2]\n        a, b, c = self.unitcell.getabc()\n        for ele in molecule.atoms:\n            if self.positional:\n                combined_atoms.append(\n                    ABCCoord(ele.sp, (float(ele[1]) + x_mod) / a,\n                             (float(ele[2]) + y_mod) / b,\n                             (float(ele[3]) + z_mod) / c))\n            else:\n                combined_atoms.append(\n                    ABCCoord(ele.sp,\n                             float(ele[1]) + x_mod,\n                             float(ele[2]) + y_mod,\n                             float(ele[3]) + z_mod))\n        if inplace:\n            self.atoms = combined_atoms\n            self.__post_init__()\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=combined_atoms,\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n\n    def append(self,\n               new_coords: ABCCoord | list[ABCCoord],\n               positional: bool,\n               inplace: bool = False) -&gt; ABCMolecule:\n        \"\"\"To add coords to the current self.atoms attribute.\n\n        Parameters\n        ----------\n        new_coords : ABCCoord or list[ABCCoord]\n            List of new coords to add to new object.\n        positional : bool\n            True if coords are positional coordinates. False if they are cartesian coordinates.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        ABCMolecule\n            _description_\n        \"\"\"\n        if not isinstance(new_coords, list):\n            new_coords = [new_coords]\n        for n, item in enumerate(new_coords):\n            if not isinstance(item, ABCCoord):\n                raise ValueError(f\"ABCMolecule.__init__() index {n} of atoms is not type ABCCoord; item = {item}\") # yapf: disable\n        if positional and not self.positional:\n            converted_coords = ABCMolecule(unitcell=self.unitcell,\n                                           positional=positional,\n                                           atoms=new_coords).convert().atoms\n            new_coords = list()\n            [\n                new_coords.append(ABCCoord(coord.sp, coord.x, coord.y,\n                                           coord.z))\n                for coord in converted_coords\n            ]\n        if not positional and self.positional:\n            converted_coords = new_coords\n            # CONVERTING CARTESIAN TO POSITIONAL COORDS\n            [\n                new_coords.append(\n                    ABCCoord(\n                        coord.sp,\n                        coord.a / self.unitcell.getabc()[0],\n                        coord.b / self.unitcell.getabc()[1],\n                        coord.c / self.unitcell.getabc()[2],\n                    )) for coord in converted_coords\n            ]\n        new_atoms = copy.copy(self.atoms)\n        new_atoms.extend(new_coords)\n        if inplace:\n            self.atoms = new_atoms\n            self.__post_init__()\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=new_atoms,\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n\n    def convert(self, method: str = \"trig\") -&gt; XYZMolecule:\n        \"\"\"Converts ABCMolecule to XYZMolecule.\n\n        Parameters\n        ----------\n        method : str, \"{'general' or 'trig' or 'linalg'}\" default 'trig'\n            Which method you want to use for converting ABCMolecule positional coords to, cartesian coordinates.\n                'general' is the general formula.\n                'trig' looks most correct and is the default.\n                'linalg' is an unfinished method using linear algebra concepts.\n\n        Returns\n        -------\n        ABCMolecule\n            _description_\n\n        Notes\n        -----\n        Maybe we can use Tristan's paid chatgpt for it to help me\n            figure out the different methods and what is going on exactly.\n        Notes on different methods:\n        'linalg' is jerry's method that is unfinished\n        'general' is the wikipedia formula which is supposedly the general solution but something is wrong about it\n        'trig' is default and is what I believe is the correct method. Lowkey got it from chatgpt but it is correct.\n        \"\"\"\n        if method not in [\"general\", \"trig\", \"linalg\"]:\n            raise ValueError(\"ABCMolecule.convert() optional argument 'method' is not 'general','trig' or 'linalg'\") # yapf: disable\n        if self.positional:\n            if method == \"general\":\n                # ====================================\n                # former code using wikipedia resource....\n                # =====================================\n                a, b, c = self.unitcell.getabc()\n                alp, bet, gam = self.unitcell.getanglesrad()\n                A = np.matrix([\n                    [\n                        a * sin(bet) *\n                        sqrt(1 - ((cot(alp)) * (cot(bet)) - (csc(alp)) *\n                                  (csc(bet)) * cos(gam))**2),\n                        0,\n                        0,\n                    ],\n                    [\n                        a * (csc(alp)) * cos(gam) - a * (cot(alp)) * cos(bet),\n                        b * sin(alp),\n                        0,\n                    ],\n                    [a * cos(bet), b * cos(alp), c],\n                ])\n                convert_atoms = list()\n                for atom in self.atoms:\n                    f = np.matrix([\n                        [atom.a],\n                        [atom.b],\n                        [atom.c],\n                    ])\n                    r = np.dot(A, f)\n                    convert_atoms.append(\n                        XYZCoord(atom.sp, float(r[0]), float(r[1]),\n                                 float(r[2])))\n                return XYZMolecule(\n                    atoms=convert_atoms,\n                    comment_line=self.comment_line,\n                    filetype=self.filetype,\n                )\n            elif method == \"trig\":\n                # ====================================\n                # created using chatgpt as a resource.\n                # quote \"correct\" method\n                # =====================================\n                a, b, c = self.unitcell.getabc()\n                alp, bet, gam = self.unitcell.getanglesrad()\n                convert_atoms: list[XYZCoord] = list()\n                for atom in self.atoms:\n                    x_car = a * atom.a + b * cos(gam) * atom.b + c * cos(bet)\n                    y_car = b * sin(gam) * atom.b + c * (\n                        cos(alp) - cos(bet) * cos(gam)) / sin(gam) * atom.c\n                    z_car = c * sqrt(1 - cos(alp)**2 - cos(bet)**2 -\n                                     cos(gam)**2 + 2 * cos(alp) * cos(bet) *\n                                     cos(gam)) * atom.c\n                    convert_atoms.append(XYZCoord(atom.sp, x_car, y_car,\n                                                  z_car))\n                return XYZMolecule(\n                    atoms=convert_atoms,\n                    comment_line=self.comment_line,\n                    filetype=self.filetype,\n                )\n            else:  # if method == 'linalg'\n                # ==================================\n                # jerry's method not fully correct\n                # ==================================\n                L = np.matrix([\n                    self.unitcell.vector_1, self.unitcell.vector_2,\n                    self.unitcell.vector_3\n                ])\n                Coord_matrix = np.transpose(\n                    np.matrix([[atom[1], atom[2], atom[3]]\n                               for atom in self.atoms]))\n                transform_matrix = np.transpose(self.unitcell.constant *\n                                                (L * Coord_matrix))\n                convert_atoms = list()\n                for n, row in enumerate(transform_matrix):\n                    convert_atoms.append(\n                        XYZCoord(self.atoms[n].sp, row[0, 0], row[0, 1],\n                                 row[0, 2]))\n                return XYZMolecule(\n                    atoms=convert_atoms,\n                    comment_line=self.comment_line,\n                    filetype=self.filetype,\n                )\n        else:\n            return XYZMolecule(\n                atoms=[\n                    XYZCoord(sp=coord.sp, x=coord.a, y=coord.b, z=coord.c)\n                    for coord in self.atoms\n                ],\n                comment_line=self.comment_line,\n                filetype=self.filetype,\n            )\n\n    def delete(self, index: MolIndex, inplace: bool = False) -&gt; ABCMolecule:\n        \"\"\"Delete INDEXED atoms in ABCMolecule.\n\n        Parameters\n        ----------\n        index : MolIndex\n            _description_\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        ABCMolecule\n            ABCMolecule with selected atoms deleted.\n        \"\"\"\n        saving_atoms: list[ABCCoord] = list()\n        del_ints: list[int] = list()\n        if type(index) != list:\n            index = [index]  # type: ignore\n        for item in index:  # type: ignore\n            for ele in self[item].atoms:\n                del_ints.append(self.atoms.index(ele))\n        saving_atoms = [\n            self.atoms[i] for i in range(len(self.atoms)) if not i in del_ints\n        ]\n        if inplace:\n            self.atoms = saving_atoms\n            self.__post_init__()\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=saving_atoms,\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n\n    def freeze_atoms(self,\n                     index: MolIndex,\n                     freeze_indexed: bool,\n                     inplace: bool = False) -&gt; ABCMolecule:\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        index : MolIndex\n            _description_\n        freeze_indexed : bool\n            _description_\n        inplace : bool, optional\n            _description_, by default False\n\n        Returns\n        -------\n        ABCMolecule\n            _description_\n        \"\"\"\n        try:\n            indexed_mol = self.__getitem__(index=index)\n            false_atoms: list[ABCCoord] = list()\n            true_atoms: list[ABCCoord] = list()\n            for coord in self.atoms:\n                if coord in indexed_mol.atoms:\n                    false_atoms.append(\n                        coord) if freeze_indexed else true_atoms.append(coord)\n                else:\n                    true_atoms.append(\n                        coord) if freeze_indexed else false_atoms.append(coord)\n        except:\n            false_atoms = self.atoms if freeze_indexed else []\n            true_atoms = [] if freeze_indexed else self.atoms\n\n        frozen_atoms: list[list[str]] = []\n        for coord in self.atoms:\n            if coord in false_atoms:\n                frozen_atoms.append([\"F\", \"F\", \"F\"])\n            elif coord in true_atoms:\n                frozen_atoms.append([\"T\", \"T\", \"T\"])\n            else:\n                raise Exception(\"ABCMolecule.freeze_atoms() runtime error. coord not in false_atoms or true_atoms\") # yapf: disable\n        if inplace:\n            self.frozen_atoms = frozen_atoms\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=self.atoms,\n            comment_line=self.comment_line,\n            frozen_atoms=frozen_atoms,\n            filetype=self.filetype,\n        )\n\n    def format(self, endline: str = \" \") -&gt; list[str]:\n        \"\"\"Returns formatted text for textbox or filewrite.\n\n        Parameters\n        ----------\n        endline : str, default \" \"\n            Endline string for each file line.\n\n        Returns\n        -------\n        list[str]\n            list of strings for vasp format with endline str as last character in string.\n\n        Notes\n        -----\n        Can replace text.append self.atoms with abcCoord.line()\n        need to add selective logic and information\n        \"\"\"\n        _len = len(str(max(self.species_amount))) + 1\n        _format_species = [f\"{ele:&lt;{_len}}\" for ele in self.species_line]\n        _format_amount = [f\"{ele:&lt;{_len}}\" for ele in self.species_amount]\n        text: list[str] = list()\n        text.append(self.comment_line + endline)\n        text.append(f\"{self.unitcell.constant:&gt;{La}.{Fa}f}\" + endline)\n        for vector in [\n                self.unitcell.vector_1, self.unitcell.vector_2,\n                self.unitcell.vector_3\n        ]:\n            text.append(\n                f\"{vector[0]:&gt;{La}.{Fa}f}{vector[1]:&gt;{La}.{Fa}f}{vector[2]:&gt;{La}.{Fa}f}\"\n                + endline)\n        text.append(\"   \".join(_format_species) + endline)\n        text.append(\"   \".join(_format_amount) + endline)\n        if self.frozen_atoms != [[\"\"]]:\n            text.append(\"Selective Dynamics \\n\")\n        if self.positional:\n            text.append(\"Cartesian\" + endline)\n        else:\n            text.append(\"Direct\" + endline)\n        if self.frozen_atoms != [[\"\"]]:\n            for i in range(len(self.atoms)):\n                text.append(\n                    f\"{self.atoms[i][1]:&gt;{La}.{Fa}f}{self.atoms[i][2]:&gt;{La}.{Fa}f}{self.atoms[i][3]:&gt;{La}.{Fa}f}\"\n                    f\"{Sa}{self.frozen_atoms[i][0]}{Sa}{self.frozen_atoms[i][1]}{Sa}{self.frozen_atoms[i][2]}\\n\"\n                )\n        else:\n            for i in range(len(self.atoms)):\n                text.append(\n                    f\"{self.atoms[i][1]:&gt;{La}.{Fa}f}{self.atoms[i][2]:&gt;{La}.{Fa}f}{self.atoms[i][3]:&gt;{La}.{Fa}f}\"\n                    + endline)\n        return text\n\n    def get_centroid(self) -&gt; tuple[float, float, float]:\n        \"\"\"Returns 3d centroid of ABCMolecule atoms.\n\n        Returns\n        -------\n        tuple[float,float,float]\n            Tuple of (x_centroid,y_centroid,z_centroid) in units Angstroms.\n        \"\"\"\n        x_list = [coord.a for coord in self.atoms]\n        y_list = [coord.b for coord in self.atoms]\n        z_list = [coord.c for coord in self.atoms]\n        x_centroid = sum(x_list) / len(x_list)\n        y_centroid = sum(y_list) / len(y_list)\n        z_centroid = sum(z_list) / len(z_list)\n        return (x_centroid, y_centroid, z_centroid)\n\n    def info(self) -&gt; None:\n        \"\"\"Prints ABCMolecule current attribute information to terminal.\"\"\"\n        species_key = [\n            x for i, x in enumerate(self.species_line)\n            if self.species_line.index(x) == i\n        ]\n        amount_dict = {sp: \"0\" for sp in species_key}\n        for ele, amt in zip(self.species_line, self.species_amount):\n            curr_value = amount_dict[ele]\n            new_value = int(amt) + int(curr_value)\n            amount_dict[ele] = str(new_value)\n        print(f\"type: ABCMolecule\\nfiletype: {self.filetype}\\ntotal atoms: {self.total}\\nspecies info: {amount_dict}\\ncomment line: '{self.comment_line}'\\nlattice constant: {self.unitcell.constant}\\nlattice matrix:\\n{self.unitcell.vector_1}\\n{self.unitcell.vector_2}\\n{self.unitcell.vector_3}\\n\") # yapf: disable\n\n    def manipulate(self,\n                   index: MolIndex,\n                   func: str,\n                   inplace: bool = False,\n                   *args: Any,\n                   **kwargs: Any) -&gt; ABCMolecule:\n        \"\"\"Rotate or move only INDEXED atoms in ABCMolecule.\n\n        Parameters\n        ----------\n        index : MolIndex\n            _description_\n        func : \"{'move' or 'rotate'}\"\n            ABCMolecule method you want to execute on the indexed atoms.\n        inplace : bool, default False\n            If True, perform operation in-place.\n        *args,**kwargs\n            Needed for the chosen function 'move' or 'rotate'.\n\n        Returns\n        -------\n        ABCMolecule or None\n            ABCMolecule with all atoms moved or None if inplace=True.\n        \"\"\"\n        i_list: list[int] = list()\n        moving_atoms: list[ABCCoord] = list()\n        if type(index) != list:\n            index = [index]  # type: ignore\n        for item in index:  # type: ignore\n            for ele in self[item].atoms:\n                i_list.append(self.atoms.index(ele))\n                moving_atoms.append(ele)\n        moving_mol = ABCMolecule(unitcell=self.unitcell,\n                                 atoms=moving_atoms,\n                                 positional=self.positional)\n        if func == \"move\":\n            new_mol = moving_mol.move(inplace=inplace, *args, **kwargs)\n        elif func == \"rotate\":\n            new_mol = moving_mol.rotate(inplace=inplace, *args, **kwargs)\n        else:\n            raise ValueError(\"ABCMolecule.manipulate() required argument 'func' not 'move' or 'rotate'\") # yapf: disable\n        new_atoms = self.atoms\n        for n, coord in zip(i_list, new_mol.atoms):\n            new_atoms[n] = coord\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=new_atoms,\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n\n    def move(self,\n             x: float = 0.0,\n             y: float = 0.0,\n             z: float = 0.0,\n             inplace: bool = False) -&gt; ABCMolecule:\n        \"\"\"Move atoms in designated directions.\n\n        Parameters\n        ----------\n        x : float, default 0.0\n            Move coord in x direction by float amount.\n        y : float, default 0.0\n            Move coord in y direction by float amount.\n        z : float, default 0.0\n            Move coord in z direction by float amount.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        ABCMolecule or None\n            ABCMolecule with all atoms moved or None if inplace=True.\n\n        \"\"\"\n        if type(x) not in [int, float]:\n            raise ValueError(f\"ABCMolecule.move() optional argument 'x' is not a number\") # yapf: disable\n        if type(y) not in [int, float]:\n            raise ValueError(f\"ABCMolecule.move() optional argument 'y' is not a number\") # yapf: disable\n        if type(z) not in [int, float]:\n            raise ValueError(f\"ABCMolecule.move() optional argument 'z' is not a number\") # yapf: disable\n        if not isinstance(inplace, bool):\n            raise ValueError(\"ABCMolecule.move() optional argument 'inplace' is not a bool\") # yapf: disable\n        return_atoms: list[ABCCoord] = list()\n        for coord in self.atoms:\n            sp = coord.sp\n            x_old = coord.a\n            y_old = coord.b\n            z_old = coord.c\n            return_atoms.append(\n                ABCCoord(sp=sp, a=x_old + x, b=y_old + y, c=z_old + z))\n        if inplace:\n            self.atoms = return_atoms\n            self.__post_init__()\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=return_atoms,\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n\n    def printt(self) -&gt; None:\n        \"\"\"Prints save file text to terminal.\"\"\"\n        for line in self.format(endline=\" \"):\n            print(line)\n\n    \"\"\"\n    # def rotate(self, axis : str, angle: float, unit: str ='deg', about_centroid: bool = True, inplace: bool = False) -&gt; ABCMolecule:\n    #     Rotate atoms about designated axis.\n\n    #     Parameters\n    #     ----------\n    #     axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n    #         Parallel axis of rotation.\n    #     angle : float\n    #         Angle of rotation.\n    #     unit : \"deg\" or \"rad\", default \"deg\"\n    #         Unit of angle argument.\n    #     about_centroid : bool, default True\n    #         If True, rotation occurs about the centroid.\n    #     inplace : bool, default False\n    #         If True, perform operation in-place.\n\n    #     Returns\n    #     -------\n    #     ABCMolecule or None\n    #         ABCMolecule with all atoms moved or None if inplace=True.\n\n    #     \n    #     if axis not in ['x','y','z']:\n    #         raise ValueError(f\"ABCMolecule.move() required argument 'angle' is not 'x' or 'y' or 'z' \") # yapf: disable \n    #     if type(angle) not in [int, float]:\n    #         raise ValueError(f\"ABCMolecule.rotate() required argument 'angle' is not a number\") # yapf: disable \n    #     if unit not in ['deg','rad']:\n    #         raise ValueError(f\"ABCMolecule.rotate() required argument 'unit' is not 'deg' or 'rad'\") # yapf: disable \n    #     if not isinstance(inplace, bool):\n    #         raise ValueError(\"ABCMolecule.rotate() optional argument 'inplace' is not a bool\") # yapf: disable \n    #     for angle in self.unitcell.getanglesdeg():\n    #         if angle &gt; UC_90_ANGLE_MAX or angle &lt; UC_90_ANGLE_MIN:\n    #             raise ValueError(f\"ABCMolecule.rotate() rotation is not possible due to the unit cell not being triclicinic\") # yapf: disable \n    #     if unit == 'deg':\n    #         angle *= pi / 180\n    #     print(f\"{axis = }\")\n    #     print(f'{angle = }')\n    #     print(f'{unit = }')\n    #     print(f'{about_centroid = }')\n    #     print(f'{inplace = }')\n    #     self.__repr__()\n    #     match axis:\n    #         case 'x':\n    #             def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n    #                 return x, y*cos(angle) - z*sin(angle), y*sin(angle)+z*cos(angle)\n    #         case 'y':\n    #             def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n    #                 return x*cos(angle) + z*sin(angle), y, z*cos(angle) - x*sin(angle)\n    #         case 'z':\n    #             def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n    #                 return x*cos(angle) - y*sin(angle), x*sin(angle) + y*cos(angle), z    \n    #     return_atoms: list[ABCCoord] = list()\n    #     if self.positional:\n    #         rotate_atom = self.convert()\n    #     else:\n    #         rotate_atom = self\n    #     print(f'{rotate_atom = !s}')\n    #     if about_centroid:\n    #         x_cent, y_cent, z_cent = rotate_atom.get_centroid()\n    #     else:\n    #         x_cent = y_cent = z_cent = 0.0\n    #     print(f'{x_cent = }')\n    #     print(f'{y_cent = }')\n    #     print(f'{z_cent = }')\n    #     for coord in rotate_atom.atoms:\n    #         rot_x, rot_y, rot_z = rotation(float(coord[1])-x_cent, float(coord[2])-y_cent, float(coord[3])-z_cent)\n    #         if self.positional:\n    #             rot_x /= self.unitcell.getabc()[0]\n    #             rot_y /= self.unitcell.getabc()[1]\n    #             rot_z /= self.unitcell.getabc()[2]\n    #         return_atoms.append(ABCCoord(sp=coord.sp,a=rot_x+x_cent,b=rot_y+y_cent,c=rot_z+z_cent))\n    #     if inplace:\n    #         self.atoms = return_atoms\n    #         self.__post_init__()\n    #     print(f'{return_atoms = }')\n    #     return ABCMolecule(unitcell=self.unitcell,positional=self.positional,atoms=return_atoms,comment_line=self.comment_line)\n    \"\"\"\n\n    def rotate(self,\n               axis: str,\n               angle: float,\n               unit: str = \"deg\",\n               about_centroid: bool = True,\n               inplace: bool = False) -&gt; ABCMolecule:\n        \"\"\"Rotate atoms about designated axis.\n\n        Parameters\n        ----------\n        axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n            Parallel axis of rotation.\n        angle : float\n            Angle of rotation.\n        unit : \"deg\" or \"rad\", default \"deg\"\n            Unit of angle argument.\n        about_centroid : bool, default True\n            If True, rotation occurs about the centroid.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        ABCMolecule or None\n            ABCMolecule with all atoms moved or None if inplace=True.\n\n        \"\"\"\n        rotate_mol = self.convert()\n        rotate_mol.rotate(axis=axis,\n                          angle=angle,\n                          unit=unit,\n                          about_centroid=about_centroid,\n                          inplace=True)\n        convert_mol = rotate_mol.convert(lattice_matrix=self.unitcell,\n                                         positional=self.positional)\n        convert_mol.comment_line = self.comment_line\n        if inplace:\n            self.atoms = convert_mol.atoms\n            self.__post_init__()\n        return convert_mol\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Save ABCMolecule instance to given filename in vasp format in current working directory.\n\n        Parameters\n        ----------\n        filename : str\n            Name you want the saved file to be.\n\n        Returns\n        -------\n        filename in current working directory.\n\n        Notes\n        -----\n        Eventually add for other file types...\n        \"\"\"\n        with open(os.path.join(os.getcwd(), filename), \"w\") as openfile:\n            for line in self.format(endline=\"\\n\"):\n                openfile.writelines(line)\n\n    def sort(self,\n             sort_method: str | list[str] | list[list[str]],\n             ascending: bool | list[bool] = True,\n             inplace: bool = False) -&gt; ABCMolecule | None:\n        \"\"\"Sort the atoms by position, species, alphabetical or atomic number.\n\n        Parameters\n        ----------\n        sort_method : str | list[str] | list[list[str]]\n            Method given by which the atoms will be sorted.\n                - if sort_method is 'x' the atoms will be sorted by their x coordinate.\n                - if sort_method is 'y' the atoms will be sorted by their y coordinate.\n                - if sort_method is 'z' the atoms will be sorted by their z coordinate.\n                - if sort_method is 'alphabetical' the atoms will be sorted in alphabetical order by their species.\n                - if sort_method is 'periodical' the atoms will be sorted by their atomic number.\n            You can also supply a list of lists with position 0 being species and position 1 being 'x','y','z', or None.\n                This will sort the coordinates by species then by the method provided for each species,\n                you can also add a list of bool for ascending values that will correspond to each species chosen method.\n            You can also supply a list of species and it will be reordered to the given order.\n        ascending : bool or list of bool, default True\n            Sort ascending vs. descending. Specify list for multiple sort orders (as described above). If this is a list of bools, must match the length of sort_method.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        ABCMolecule or None\n            ABCMolecule with all atoms moved or None if inplace=True.\n\n        Notes\n        -----\n        sort method +x,-x,+y,-y,+z,-z,species,sp list,alphabetical,periodical,\n        \"\"\"\n        if isinstance(sort_method, str):\n            if sort_method not in [\n                    \"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\", None\n            ]:\n                raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' is not one of 'x','y','z','alphabetical','periodical'\") # yapf: disable\n            # making individual string so it can work in for loop enumerate below\n            sort_method = [sort_method]\n        elif isinstance(sort_method, list) or isinstance(sort_method, tuple):\n            if len(sort_method) != len(self.species_line):\n                raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' not the same length of amount of species in ABCMolecule\") # yapf: disable\n            for item in sort_method:\n                if isinstance(item, str):\n                    item = [item]\n                if not isinstance(item, list) and not isinstance(item, tuple):\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item not correct type\") # yapf: disable\n                if len(item) == 1:\n                    if item[0] not in self.species_line:\n                        raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line (len(item)=1)\") # yapf: disable\n                elif len(item) == 2:\n                    if item[0] not in self.species_line:\n                        raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line\") # yapf: disable\n                    if item[1] not in [\"x\", \"y\", \"z\", \"None\", None]:\n                        raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item position 1 is not one of type 'x','y','z','None',None (len(item)=2)\") # yapf: disable\n                else:\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item length &gt; 2\") # yapf: disable\n        else:\n            raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' not correct types\") # yapf: disable\n        if isinstance(ascending, list) or isinstance(ascending, tuple):\n            if not isinstance(sort_method, list) and not isinstance(\n                    sort_method, tuple):\n                raise ValueError(\"ABCMolecule.sort() ascending is type list but sortmethod is not type list\") # yapf: disable\n            if len(sort_method) != len(ascending):\n                raise ValueError(\"ABCMolecule.sort() length of ascending list not equivalent to length of sort method\") # yapf: disable\n            if not all([isinstance(item, bool) for item in ascending]):\n                raise ValueError(\"ABCMolecule.sort() ascending list[bool] not all bool type\") # yapf: disable\n        elif not isinstance(ascending, bool):\n            raise ValueError(\"ABCMolecule.sort() ascending bool type not bool type\") # yapf: disable\n        return_atoms: list[ABCCoord] = list()\n        for n, item in enumerate(sort_method):\n            if isinstance(ascending, bool):\n                reverse_bool = False if ascending else True\n            elif isinstance(ascending, list) and len(ascending) == 1:\n                reverse_bool = False if ascending[0] else True\n            elif len(ascending) == len(sort_method):\n                reverse_bool = False if ascending[n] else True\n            else:\n                raise ValueError(\"ABCMolecule.sort() ascending argument is wrong\") # yapf: disable\n            if isinstance(item, list) or isinstance(item, tuple):\n                if len(item) == 1:\n                    tobesorted = self.atoms  # for string\n                    method = item[0]\n                elif item[0] in self.species_line:\n                    tobesorted = self[item[0]].atoms\n                    method = item[1]\n                else:\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' is not correct\") # yapf: disable\n            else:  #if isinstance(item, str):\n                if item in self.species_line:\n                    tobesorted = self[item].atoms\n                    method = \"None\"\n                elif item in [\n                        \"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\",\n                        None\n                ]:\n                    # raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list species index 1 is not one of 'x','y','z','alphabetical','periodical','None',None\") # yapf: disable\n                    method = item\n                    tobesorted = self.atoms\n                else:\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list species does not contain species\") # yapf: disable\n            if method == \"x\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x[1], reverse=reverse_bool))\n            elif method == \"y\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x[2], reverse=reverse_bool))\n            elif method == \"z\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x[3], reverse=reverse_bool))\n            elif method == \"alphabetical\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x.sp, reverse=reverse_bool))\n            elif method == \"periodical\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: ACCEPTED_ELEMENTS.index(x.sp), reverse=reverse_bool))\n            else:\n                return_atoms.extend(tobesorted)\n        if inplace:\n            self.atoms = return_atoms\n            self.__post_init__()\n        return ABCMolecule(\n            unitcell=self.unitcell,\n            positional=self.positional,\n            atoms=return_atoms,\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.add_coords","title":"<code>add_coords(molecule, axis, absorbent_reference, surface_reference, dist, inplace=False)</code>","text":"<p>Add a new Molecule object to the current ABCMolecule object very precisely.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.add_coords--parameters","title":"Parameters","text":"<p>molecule : ABCMolecule or XYZMolecule     description axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"     Placement of new molecule will be in direction of axis. absorbent_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"     description surface_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"     description dist : float     sign of float determines what direction the new molecule is placed. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.add_coords--returns","title":"Returns","text":"<p>ABCMolecule     ABCMolecule with new atoms added.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.add_coords--notes","title":"Notes","text":"<p>Need to add CoordType logic. Need to add ABCMolecule logic. NEED TO ADD absorbent/surface reference can of type coord also probably need coord protocol NEED TO ADD LOGIC FOR CONVERTING TO DIFFERENT ATOM TYPES operation happens in cartesian coordinates and then the new coords are converted back to positional need to ensure operation only happens in a trigonal unit cell until i find the generic unitcell formula</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def add_coords(self,\n               molecule: ABCMolecule | XYZMolecule,\n               axis: str | int,\n               absorbent_reference: str | ABCCoord,\n               surface_reference: str | ABCCoord,\n               dist: float,\n               inplace: bool = False) -&gt; ABCMolecule:\n    \"\"\"Add a new Molecule object to the current ABCMolecule object very precisely.\n\n    Parameters\n    ----------\n    molecule : ABCMolecule or XYZMolecule\n        _description_\n    axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n        Placement of new molecule will be in direction of axis.\n    absorbent_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n        _description_\n    surface_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n        _description_\n    dist : float\n        sign of float determines what direction the new molecule is placed.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    ABCMolecule\n        ABCMolecule with new atoms added.\n\n    Notes\n    ------\n    Need to add CoordType logic.\n    Need to add ABCMolecule logic.\n    NEED TO ADD absorbent/surface reference can of type coord also probably need coord protocol\n    NEED TO ADD LOGIC FOR CONVERTING TO DIFFERENT ATOM TYPES\n    operation happens in cartesian coordinates and then the new coords are converted back to positional\n    need to ensure operation only happens in a trigonal unit cell until i find the generic unitcell formula\n    \"\"\"\n    if axis not in [\"x\", \"y\", \"z\"] and axis not in [0, 1, 2]:\n        raise ValueError(f\"XYZMolecule.add_coords() required argument 'angle' is not 'x' or 'y' or 'z' or 1 or 2 or 3 \") # yapf: disable\n    match axis:\n        case \"x\":\n            axis_int = 0\n        case \"y\":\n            axis_int = 1\n        case \"z\":\n            axis_int = 2\n        case _:\n            axis_int = int(axis)\n    if isinstance(molecule, ABCMolecule):\n        if molecule.positional:\n            molecule = molecule.convert()\n    elif isinstance(molecule, XYZMolecule):\n        pass\n    else:\n        raise ValueError(\"ABCMolecule.add_coords() required argument 'molecule' not correct type\") # yapf: disable\n    # needed to not append to memory and return only changed object\n    combined_atoms = copy.copy(self.atoms)\n    # need convert bc operation happens in cartesian coords\n    sur_centroids = self.convert().get_centroid()\n    sur_mod = [sur_centroids[0], sur_centroids[1], sur_centroids[2]]\n    x_import_centroid, y_import_centroid, z_import_centroid = molecule.get_centroid(\n    )\n    abs_centroids = [\n        x_import_centroid, y_import_centroid, z_import_centroid\n    ]\n    x_import_list = [float(coord[1]) for coord in molecule.atoms]\n    y_import_list = [float(coord[2]) for coord in molecule.atoms]\n    z_import_list = [float(coord[3]) for coord in molecule.atoms]\n    abs_lists = (x_import_list, y_import_list, z_import_list)\n    atom_list = self.convert().atoms if self.positional else self.atoms\n    x_curr_list = [float(coord[1]) for coord in atom_list]\n    y_curr_list = [float(coord[2]) for coord in atom_list]\n    z_curr_list = [float(coord[3]) for coord in atom_list]\n    sur_lists = (x_curr_list, y_curr_list, z_curr_list)\n    # finding absorbent values\n    if absorbent_reference == \"Centroid\":\n        abs_mod = abs_centroids\n    elif absorbent_reference == \"Top\" or absorbent_reference == \"Bottom\":\n        abs_mod = abs_centroids\n        if absorbent_reference == \"Top\":\n            sort_func = max\n        else:  # if absorbent_reference == \"Bottom\":\n            sort_func = min\n        abs_mod[axis_int] = sort_func(abs_lists[axis_int])\n    else:\n        abs_mod = [0.0, 0.0, 0.0]\n    # finding surface values now\n    if not isinstance(surface_reference, ABCCoord) and not isinstance(\n            surface_reference, str):\n        raise ValueError(\"ABCMolecule.add_coords() required argument 'surface_reference' is not type str or ABCCoord.\") # yapf: disable\n    if isinstance(surface_reference, ABCCoord):\n        pass\n    elif surface_reference == \"Centroid\":\n        sur_mod = sur_centroids\n    elif surface_reference == \"(0.5,0.5,0.5)\":\n        sur_mod = [0.5, 0.5, 0.5]\n    elif surface_reference == \"Top\" or surface_reference == \"Bottom\":\n        if surface_reference == \"Top\":\n            sort_func = max\n        # if surface_reference == ABSORBENT_OPTIONS['starting_surface_list'][1]:\n        else:\n            sort_func = min\n        sur_mod[axis_int] = sort_func(sur_lists[axis_int])\n    elif \"Most positive \" in surface_reference or \"Most negative\" in surface_reference:\n        species = surface_reference[14:]\n        if \"Most positive \" in surface_reference:\n            sort_func = max\n        else:  # if \"Most negative\" in surface_reference:\n            sort_func = min\n        species_import_list = [\n            float(coord[axis_int + 1]) for coord in self.atoms\n            if coord.sp == species\n        ]\n        sur_mod[axis_int] = sort_func(species_import_list)\n    else:  # necessary for add atom\n        sur_mod = [0, 0, 0]  # if surface_reference == 'origin'\n    # math for finding displacement distanceance\n    distance = [0.0, 0.0, 0.0]\n    distance[axis_int] = dist\n    # print(f'{sur_mod = }')\n    # print(f'{abs_mod = }')\n    x_mod = sur_mod[0] - abs_mod[0] + distance[0]\n    y_mod = sur_mod[1] - abs_mod[1] + distance[1]\n    z_mod = sur_mod[2] - abs_mod[2] + distance[2]\n    a, b, c = self.unitcell.getabc()\n    for ele in molecule.atoms:\n        if self.positional:\n            combined_atoms.append(\n                ABCCoord(ele.sp, (float(ele[1]) + x_mod) / a,\n                         (float(ele[2]) + y_mod) / b,\n                         (float(ele[3]) + z_mod) / c))\n        else:\n            combined_atoms.append(\n                ABCCoord(ele.sp,\n                         float(ele[1]) + x_mod,\n                         float(ele[2]) + y_mod,\n                         float(ele[3]) + z_mod))\n    if inplace:\n        self.atoms = combined_atoms\n        self.__post_init__()\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=combined_atoms,\n        comment_line=self.comment_line,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.append","title":"<code>append(new_coords, positional, inplace=False)</code>","text":"<p>To add coords to the current self.atoms attribute.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.append--parameters","title":"Parameters","text":"<p>new_coords : ABCCoord or list[ABCCoord]     List of new coords to add to new object. positional : bool     True if coords are positional coordinates. False if they are cartesian coordinates. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.append--returns","title":"Returns","text":"<p>ABCMolecule     description</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def append(self,\n           new_coords: ABCCoord | list[ABCCoord],\n           positional: bool,\n           inplace: bool = False) -&gt; ABCMolecule:\n    \"\"\"To add coords to the current self.atoms attribute.\n\n    Parameters\n    ----------\n    new_coords : ABCCoord or list[ABCCoord]\n        List of new coords to add to new object.\n    positional : bool\n        True if coords are positional coordinates. False if they are cartesian coordinates.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n    if not isinstance(new_coords, list):\n        new_coords = [new_coords]\n    for n, item in enumerate(new_coords):\n        if not isinstance(item, ABCCoord):\n            raise ValueError(f\"ABCMolecule.__init__() index {n} of atoms is not type ABCCoord; item = {item}\") # yapf: disable\n    if positional and not self.positional:\n        converted_coords = ABCMolecule(unitcell=self.unitcell,\n                                       positional=positional,\n                                       atoms=new_coords).convert().atoms\n        new_coords = list()\n        [\n            new_coords.append(ABCCoord(coord.sp, coord.x, coord.y,\n                                       coord.z))\n            for coord in converted_coords\n        ]\n    if not positional and self.positional:\n        converted_coords = new_coords\n        # CONVERTING CARTESIAN TO POSITIONAL COORDS\n        [\n            new_coords.append(\n                ABCCoord(\n                    coord.sp,\n                    coord.a / self.unitcell.getabc()[0],\n                    coord.b / self.unitcell.getabc()[1],\n                    coord.c / self.unitcell.getabc()[2],\n                )) for coord in converted_coords\n        ]\n    new_atoms = copy.copy(self.atoms)\n    new_atoms.extend(new_coords)\n    if inplace:\n        self.atoms = new_atoms\n        self.__post_init__()\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=new_atoms,\n        comment_line=self.comment_line,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.convert","title":"<code>convert(method='trig')</code>","text":"<p>Converts ABCMolecule to XYZMolecule.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.convert--parameters","title":"Parameters","text":"<p>method : str, \"{'general' or 'trig' or 'linalg'}\" default 'trig'     Which method you want to use for converting ABCMolecule positional coords to, cartesian coordinates.         'general' is the general formula.         'trig' looks most correct and is the default.         'linalg' is an unfinished method using linear algebra concepts.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.convert--returns","title":"Returns","text":"<p>ABCMolecule     description</p>"},{"location":"reference/#molecule_lib.ABCMolecule.convert--notes","title":"Notes","text":"<p>Maybe we can use Tristan's paid chatgpt for it to help me     figure out the different methods and what is going on exactly. Notes on different methods: 'linalg' is jerry's method that is unfinished 'general' is the wikipedia formula which is supposedly the general solution but something is wrong about it 'trig' is default and is what I believe is the correct method. Lowkey got it from chatgpt but it is correct.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def convert(self, method: str = \"trig\") -&gt; XYZMolecule:\n    \"\"\"Converts ABCMolecule to XYZMolecule.\n\n    Parameters\n    ----------\n    method : str, \"{'general' or 'trig' or 'linalg'}\" default 'trig'\n        Which method you want to use for converting ABCMolecule positional coords to, cartesian coordinates.\n            'general' is the general formula.\n            'trig' looks most correct and is the default.\n            'linalg' is an unfinished method using linear algebra concepts.\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n\n    Notes\n    -----\n    Maybe we can use Tristan's paid chatgpt for it to help me\n        figure out the different methods and what is going on exactly.\n    Notes on different methods:\n    'linalg' is jerry's method that is unfinished\n    'general' is the wikipedia formula which is supposedly the general solution but something is wrong about it\n    'trig' is default and is what I believe is the correct method. Lowkey got it from chatgpt but it is correct.\n    \"\"\"\n    if method not in [\"general\", \"trig\", \"linalg\"]:\n        raise ValueError(\"ABCMolecule.convert() optional argument 'method' is not 'general','trig' or 'linalg'\") # yapf: disable\n    if self.positional:\n        if method == \"general\":\n            # ====================================\n            # former code using wikipedia resource....\n            # =====================================\n            a, b, c = self.unitcell.getabc()\n            alp, bet, gam = self.unitcell.getanglesrad()\n            A = np.matrix([\n                [\n                    a * sin(bet) *\n                    sqrt(1 - ((cot(alp)) * (cot(bet)) - (csc(alp)) *\n                              (csc(bet)) * cos(gam))**2),\n                    0,\n                    0,\n                ],\n                [\n                    a * (csc(alp)) * cos(gam) - a * (cot(alp)) * cos(bet),\n                    b * sin(alp),\n                    0,\n                ],\n                [a * cos(bet), b * cos(alp), c],\n            ])\n            convert_atoms = list()\n            for atom in self.atoms:\n                f = np.matrix([\n                    [atom.a],\n                    [atom.b],\n                    [atom.c],\n                ])\n                r = np.dot(A, f)\n                convert_atoms.append(\n                    XYZCoord(atom.sp, float(r[0]), float(r[1]),\n                             float(r[2])))\n            return XYZMolecule(\n                atoms=convert_atoms,\n                comment_line=self.comment_line,\n                filetype=self.filetype,\n            )\n        elif method == \"trig\":\n            # ====================================\n            # created using chatgpt as a resource.\n            # quote \"correct\" method\n            # =====================================\n            a, b, c = self.unitcell.getabc()\n            alp, bet, gam = self.unitcell.getanglesrad()\n            convert_atoms: list[XYZCoord] = list()\n            for atom in self.atoms:\n                x_car = a * atom.a + b * cos(gam) * atom.b + c * cos(bet)\n                y_car = b * sin(gam) * atom.b + c * (\n                    cos(alp) - cos(bet) * cos(gam)) / sin(gam) * atom.c\n                z_car = c * sqrt(1 - cos(alp)**2 - cos(bet)**2 -\n                                 cos(gam)**2 + 2 * cos(alp) * cos(bet) *\n                                 cos(gam)) * atom.c\n                convert_atoms.append(XYZCoord(atom.sp, x_car, y_car,\n                                              z_car))\n            return XYZMolecule(\n                atoms=convert_atoms,\n                comment_line=self.comment_line,\n                filetype=self.filetype,\n            )\n        else:  # if method == 'linalg'\n            # ==================================\n            # jerry's method not fully correct\n            # ==================================\n            L = np.matrix([\n                self.unitcell.vector_1, self.unitcell.vector_2,\n                self.unitcell.vector_3\n            ])\n            Coord_matrix = np.transpose(\n                np.matrix([[atom[1], atom[2], atom[3]]\n                           for atom in self.atoms]))\n            transform_matrix = np.transpose(self.unitcell.constant *\n                                            (L * Coord_matrix))\n            convert_atoms = list()\n            for n, row in enumerate(transform_matrix):\n                convert_atoms.append(\n                    XYZCoord(self.atoms[n].sp, row[0, 0], row[0, 1],\n                             row[0, 2]))\n            return XYZMolecule(\n                atoms=convert_atoms,\n                comment_line=self.comment_line,\n                filetype=self.filetype,\n            )\n    else:\n        return XYZMolecule(\n            atoms=[\n                XYZCoord(sp=coord.sp, x=coord.a, y=coord.b, z=coord.c)\n                for coord in self.atoms\n            ],\n            comment_line=self.comment_line,\n            filetype=self.filetype,\n        )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.delete","title":"<code>delete(index, inplace=False)</code>","text":"<p>Delete INDEXED atoms in ABCMolecule.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.delete--parameters","title":"Parameters","text":"<p>index : MolIndex     description inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.delete--returns","title":"Returns","text":"<p>ABCMolecule     ABCMolecule with selected atoms deleted.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def delete(self, index: MolIndex, inplace: bool = False) -&gt; ABCMolecule:\n    \"\"\"Delete INDEXED atoms in ABCMolecule.\n\n    Parameters\n    ----------\n    index : MolIndex\n        _description_\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    ABCMolecule\n        ABCMolecule with selected atoms deleted.\n    \"\"\"\n    saving_atoms: list[ABCCoord] = list()\n    del_ints: list[int] = list()\n    if type(index) != list:\n        index = [index]  # type: ignore\n    for item in index:  # type: ignore\n        for ele in self[item].atoms:\n            del_ints.append(self.atoms.index(ele))\n    saving_atoms = [\n        self.atoms[i] for i in range(len(self.atoms)) if not i in del_ints\n    ]\n    if inplace:\n        self.atoms = saving_atoms\n        self.__post_init__()\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=saving_atoms,\n        comment_line=self.comment_line,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.freeze_atoms","title":"<code>freeze_atoms(index, freeze_indexed, inplace=False)</code>","text":"<p>summary</p>"},{"location":"reference/#molecule_lib.ABCMolecule.freeze_atoms--parameters","title":"Parameters","text":"<p>index : MolIndex     description freeze_indexed : bool     description inplace : bool, optional     description, by default False</p>"},{"location":"reference/#molecule_lib.ABCMolecule.freeze_atoms--returns","title":"Returns","text":"<p>ABCMolecule     description</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def freeze_atoms(self,\n                 index: MolIndex,\n                 freeze_indexed: bool,\n                 inplace: bool = False) -&gt; ABCMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    index : MolIndex\n        _description_\n    freeze_indexed : bool\n        _description_\n    inplace : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n    try:\n        indexed_mol = self.__getitem__(index=index)\n        false_atoms: list[ABCCoord] = list()\n        true_atoms: list[ABCCoord] = list()\n        for coord in self.atoms:\n            if coord in indexed_mol.atoms:\n                false_atoms.append(\n                    coord) if freeze_indexed else true_atoms.append(coord)\n            else:\n                true_atoms.append(\n                    coord) if freeze_indexed else false_atoms.append(coord)\n    except:\n        false_atoms = self.atoms if freeze_indexed else []\n        true_atoms = [] if freeze_indexed else self.atoms\n\n    frozen_atoms: list[list[str]] = []\n    for coord in self.atoms:\n        if coord in false_atoms:\n            frozen_atoms.append([\"F\", \"F\", \"F\"])\n        elif coord in true_atoms:\n            frozen_atoms.append([\"T\", \"T\", \"T\"])\n        else:\n            raise Exception(\"ABCMolecule.freeze_atoms() runtime error. coord not in false_atoms or true_atoms\") # yapf: disable\n    if inplace:\n        self.frozen_atoms = frozen_atoms\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=self.atoms,\n        comment_line=self.comment_line,\n        frozen_atoms=frozen_atoms,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.format","title":"<code>format(endline=' ')</code>","text":"<p>Returns formatted text for textbox or filewrite.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.format--parameters","title":"Parameters","text":"<p>endline : str, default \" \"     Endline string for each file line.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.format--returns","title":"Returns","text":"<p>list[str]     list of strings for vasp format with endline str as last character in string.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.format--notes","title":"Notes","text":"<p>Can replace text.append self.atoms with abcCoord.line() need to add selective logic and information</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def format(self, endline: str = \" \") -&gt; list[str]:\n    \"\"\"Returns formatted text for textbox or filewrite.\n\n    Parameters\n    ----------\n    endline : str, default \" \"\n        Endline string for each file line.\n\n    Returns\n    -------\n    list[str]\n        list of strings for vasp format with endline str as last character in string.\n\n    Notes\n    -----\n    Can replace text.append self.atoms with abcCoord.line()\n    need to add selective logic and information\n    \"\"\"\n    _len = len(str(max(self.species_amount))) + 1\n    _format_species = [f\"{ele:&lt;{_len}}\" for ele in self.species_line]\n    _format_amount = [f\"{ele:&lt;{_len}}\" for ele in self.species_amount]\n    text: list[str] = list()\n    text.append(self.comment_line + endline)\n    text.append(f\"{self.unitcell.constant:&gt;{La}.{Fa}f}\" + endline)\n    for vector in [\n            self.unitcell.vector_1, self.unitcell.vector_2,\n            self.unitcell.vector_3\n    ]:\n        text.append(\n            f\"{vector[0]:&gt;{La}.{Fa}f}{vector[1]:&gt;{La}.{Fa}f}{vector[2]:&gt;{La}.{Fa}f}\"\n            + endline)\n    text.append(\"   \".join(_format_species) + endline)\n    text.append(\"   \".join(_format_amount) + endline)\n    if self.frozen_atoms != [[\"\"]]:\n        text.append(\"Selective Dynamics \\n\")\n    if self.positional:\n        text.append(\"Cartesian\" + endline)\n    else:\n        text.append(\"Direct\" + endline)\n    if self.frozen_atoms != [[\"\"]]:\n        for i in range(len(self.atoms)):\n            text.append(\n                f\"{self.atoms[i][1]:&gt;{La}.{Fa}f}{self.atoms[i][2]:&gt;{La}.{Fa}f}{self.atoms[i][3]:&gt;{La}.{Fa}f}\"\n                f\"{Sa}{self.frozen_atoms[i][0]}{Sa}{self.frozen_atoms[i][1]}{Sa}{self.frozen_atoms[i][2]}\\n\"\n            )\n    else:\n        for i in range(len(self.atoms)):\n            text.append(\n                f\"{self.atoms[i][1]:&gt;{La}.{Fa}f}{self.atoms[i][2]:&gt;{La}.{Fa}f}{self.atoms[i][3]:&gt;{La}.{Fa}f}\"\n                + endline)\n    return text\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.get_centroid","title":"<code>get_centroid()</code>","text":"<p>Returns 3d centroid of ABCMolecule atoms.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.get_centroid--returns","title":"Returns","text":"<p>tuple[float,float,float]     Tuple of (x_centroid,y_centroid,z_centroid) in units Angstroms.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def get_centroid(self) -&gt; tuple[float, float, float]:\n    \"\"\"Returns 3d centroid of ABCMolecule atoms.\n\n    Returns\n    -------\n    tuple[float,float,float]\n        Tuple of (x_centroid,y_centroid,z_centroid) in units Angstroms.\n    \"\"\"\n    x_list = [coord.a for coord in self.atoms]\n    y_list = [coord.b for coord in self.atoms]\n    z_list = [coord.c for coord in self.atoms]\n    x_centroid = sum(x_list) / len(x_list)\n    y_centroid = sum(y_list) / len(y_list)\n    z_centroid = sum(z_list) / len(z_list)\n    return (x_centroid, y_centroid, z_centroid)\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.info","title":"<code>info()</code>","text":"<p>Prints ABCMolecule current attribute information to terminal.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def info(self) -&gt; None:\n    \"\"\"Prints ABCMolecule current attribute information to terminal.\"\"\"\n    species_key = [\n        x for i, x in enumerate(self.species_line)\n        if self.species_line.index(x) == i\n    ]\n    amount_dict = {sp: \"0\" for sp in species_key}\n    for ele, amt in zip(self.species_line, self.species_amount):\n        curr_value = amount_dict[ele]\n        new_value = int(amt) + int(curr_value)\n        amount_dict[ele] = str(new_value)\n    print(f\"type: ABCMolecule\\nfiletype: {self.filetype}\\ntotal atoms: {self.total}\\nspecies info: {amount_dict}\\ncomment line: '{self.comment_line}'\\nlattice constant: {self.unitcell.constant}\\nlattice matrix:\\n{self.unitcell.vector_1}\\n{self.unitcell.vector_2}\\n{self.unitcell.vector_3}\\n\") # yapf: disable\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.manipulate","title":"<code>manipulate(index, func, inplace=False, *args, **kwargs)</code>","text":"<p>Rotate or move only INDEXED atoms in ABCMolecule.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.manipulate--parameters","title":"Parameters","text":"<p>index : MolIndex     description func : \"{'move' or 'rotate'}\"     ABCMolecule method you want to execute on the indexed atoms. inplace : bool, default False     If True, perform operation in-place. args,*kwargs     Needed for the chosen function 'move' or 'rotate'.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.manipulate--returns","title":"Returns","text":"<p>ABCMolecule or None     ABCMolecule with all atoms moved or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def manipulate(self,\n               index: MolIndex,\n               func: str,\n               inplace: bool = False,\n               *args: Any,\n               **kwargs: Any) -&gt; ABCMolecule:\n    \"\"\"Rotate or move only INDEXED atoms in ABCMolecule.\n\n    Parameters\n    ----------\n    index : MolIndex\n        _description_\n    func : \"{'move' or 'rotate'}\"\n        ABCMolecule method you want to execute on the indexed atoms.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    *args,**kwargs\n        Needed for the chosen function 'move' or 'rotate'.\n\n    Returns\n    -------\n    ABCMolecule or None\n        ABCMolecule with all atoms moved or None if inplace=True.\n    \"\"\"\n    i_list: list[int] = list()\n    moving_atoms: list[ABCCoord] = list()\n    if type(index) != list:\n        index = [index]  # type: ignore\n    for item in index:  # type: ignore\n        for ele in self[item].atoms:\n            i_list.append(self.atoms.index(ele))\n            moving_atoms.append(ele)\n    moving_mol = ABCMolecule(unitcell=self.unitcell,\n                             atoms=moving_atoms,\n                             positional=self.positional)\n    if func == \"move\":\n        new_mol = moving_mol.move(inplace=inplace, *args, **kwargs)\n    elif func == \"rotate\":\n        new_mol = moving_mol.rotate(inplace=inplace, *args, **kwargs)\n    else:\n        raise ValueError(\"ABCMolecule.manipulate() required argument 'func' not 'move' or 'rotate'\") # yapf: disable\n    new_atoms = self.atoms\n    for n, coord in zip(i_list, new_mol.atoms):\n        new_atoms[n] = coord\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=new_atoms,\n        comment_line=self.comment_line,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.move","title":"<code>move(x=0.0, y=0.0, z=0.0, inplace=False)</code>","text":"<p>Move atoms in designated directions.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.move--parameters","title":"Parameters","text":"<p>x : float, default 0.0     Move coord in x direction by float amount. y : float, default 0.0     Move coord in y direction by float amount. z : float, default 0.0     Move coord in z direction by float amount. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.move--returns","title":"Returns","text":"<p>ABCMolecule or None     ABCMolecule with all atoms moved or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def move(self,\n         x: float = 0.0,\n         y: float = 0.0,\n         z: float = 0.0,\n         inplace: bool = False) -&gt; ABCMolecule:\n    \"\"\"Move atoms in designated directions.\n\n    Parameters\n    ----------\n    x : float, default 0.0\n        Move coord in x direction by float amount.\n    y : float, default 0.0\n        Move coord in y direction by float amount.\n    z : float, default 0.0\n        Move coord in z direction by float amount.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    ABCMolecule or None\n        ABCMolecule with all atoms moved or None if inplace=True.\n\n    \"\"\"\n    if type(x) not in [int, float]:\n        raise ValueError(f\"ABCMolecule.move() optional argument 'x' is not a number\") # yapf: disable\n    if type(y) not in [int, float]:\n        raise ValueError(f\"ABCMolecule.move() optional argument 'y' is not a number\") # yapf: disable\n    if type(z) not in [int, float]:\n        raise ValueError(f\"ABCMolecule.move() optional argument 'z' is not a number\") # yapf: disable\n    if not isinstance(inplace, bool):\n        raise ValueError(\"ABCMolecule.move() optional argument 'inplace' is not a bool\") # yapf: disable\n    return_atoms: list[ABCCoord] = list()\n    for coord in self.atoms:\n        sp = coord.sp\n        x_old = coord.a\n        y_old = coord.b\n        z_old = coord.c\n        return_atoms.append(\n            ABCCoord(sp=sp, a=x_old + x, b=y_old + y, c=z_old + z))\n    if inplace:\n        self.atoms = return_atoms\n        self.__post_init__()\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=return_atoms,\n        comment_line=self.comment_line,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.printt","title":"<code>printt()</code>","text":"<p>Prints save file text to terminal.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def printt(self) -&gt; None:\n    \"\"\"Prints save file text to terminal.\"\"\"\n    for line in self.format(endline=\" \"):\n        print(line)\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.rotate","title":"<code>rotate(axis, angle, unit='deg', about_centroid=True, inplace=False)</code>","text":"<p>Rotate atoms about designated axis.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.rotate--parameters","title":"Parameters","text":"<p>axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"     Parallel axis of rotation. angle : float     Angle of rotation. unit : \"deg\" or \"rad\", default \"deg\"     Unit of angle argument. about_centroid : bool, default True     If True, rotation occurs about the centroid. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.rotate--returns","title":"Returns","text":"<p>ABCMolecule or None     ABCMolecule with all atoms moved or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def rotate(self,\n           axis: str,\n           angle: float,\n           unit: str = \"deg\",\n           about_centroid: bool = True,\n           inplace: bool = False) -&gt; ABCMolecule:\n    \"\"\"Rotate atoms about designated axis.\n\n    Parameters\n    ----------\n    axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n        Parallel axis of rotation.\n    angle : float\n        Angle of rotation.\n    unit : \"deg\" or \"rad\", default \"deg\"\n        Unit of angle argument.\n    about_centroid : bool, default True\n        If True, rotation occurs about the centroid.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    ABCMolecule or None\n        ABCMolecule with all atoms moved or None if inplace=True.\n\n    \"\"\"\n    rotate_mol = self.convert()\n    rotate_mol.rotate(axis=axis,\n                      angle=angle,\n                      unit=unit,\n                      about_centroid=about_centroid,\n                      inplace=True)\n    convert_mol = rotate_mol.convert(lattice_matrix=self.unitcell,\n                                     positional=self.positional)\n    convert_mol.comment_line = self.comment_line\n    if inplace:\n        self.atoms = convert_mol.atoms\n        self.__post_init__()\n    return convert_mol\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.save","title":"<code>save(filename)</code>","text":"<p>Save ABCMolecule instance to given filename in vasp format in current working directory.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.save--parameters","title":"Parameters","text":"<p>filename : str     Name you want the saved file to be.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.save--returns","title":"Returns","text":"<p>filename in current working directory.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.save--notes","title":"Notes","text":"<p>Eventually add for other file types...</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Save ABCMolecule instance to given filename in vasp format in current working directory.\n\n    Parameters\n    ----------\n    filename : str\n        Name you want the saved file to be.\n\n    Returns\n    -------\n    filename in current working directory.\n\n    Notes\n    -----\n    Eventually add for other file types...\n    \"\"\"\n    with open(os.path.join(os.getcwd(), filename), \"w\") as openfile:\n        for line in self.format(endline=\"\\n\"):\n            openfile.writelines(line)\n</code></pre>"},{"location":"reference/#molecule_lib.ABCMolecule.sort","title":"<code>sort(sort_method, ascending=True, inplace=False)</code>","text":"<p>Sort the atoms by position, species, alphabetical or atomic number.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.sort--parameters","title":"Parameters","text":"<p>sort_method : str | list[str] | list[list[str]]     Method given by which the atoms will be sorted.         - if sort_method is 'x' the atoms will be sorted by their x coordinate.         - if sort_method is 'y' the atoms will be sorted by their y coordinate.         - if sort_method is 'z' the atoms will be sorted by their z coordinate.         - if sort_method is 'alphabetical' the atoms will be sorted in alphabetical order by their species.         - if sort_method is 'periodical' the atoms will be sorted by their atomic number.     You can also supply a list of lists with position 0 being species and position 1 being 'x','y','z', or None.         This will sort the coordinates by species then by the method provided for each species,         you can also add a list of bool for ascending values that will correspond to each species chosen method.     You can also supply a list of species and it will be reordered to the given order. ascending : bool or list of bool, default True     Sort ascending vs. descending. Specify list for multiple sort orders (as described above). If this is a list of bools, must match the length of sort_method. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.sort--returns","title":"Returns","text":"<p>ABCMolecule or None     ABCMolecule with all atoms moved or None if inplace=True.</p>"},{"location":"reference/#molecule_lib.ABCMolecule.sort--notes","title":"Notes","text":"<p>sort method +x,-x,+y,-y,+z,-z,species,sp list,alphabetical,periodical,</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def sort(self,\n         sort_method: str | list[str] | list[list[str]],\n         ascending: bool | list[bool] = True,\n         inplace: bool = False) -&gt; ABCMolecule | None:\n    \"\"\"Sort the atoms by position, species, alphabetical or atomic number.\n\n    Parameters\n    ----------\n    sort_method : str | list[str] | list[list[str]]\n        Method given by which the atoms will be sorted.\n            - if sort_method is 'x' the atoms will be sorted by their x coordinate.\n            - if sort_method is 'y' the atoms will be sorted by their y coordinate.\n            - if sort_method is 'z' the atoms will be sorted by their z coordinate.\n            - if sort_method is 'alphabetical' the atoms will be sorted in alphabetical order by their species.\n            - if sort_method is 'periodical' the atoms will be sorted by their atomic number.\n        You can also supply a list of lists with position 0 being species and position 1 being 'x','y','z', or None.\n            This will sort the coordinates by species then by the method provided for each species,\n            you can also add a list of bool for ascending values that will correspond to each species chosen method.\n        You can also supply a list of species and it will be reordered to the given order.\n    ascending : bool or list of bool, default True\n        Sort ascending vs. descending. Specify list for multiple sort orders (as described above). If this is a list of bools, must match the length of sort_method.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    ABCMolecule or None\n        ABCMolecule with all atoms moved or None if inplace=True.\n\n    Notes\n    -----\n    sort method +x,-x,+y,-y,+z,-z,species,sp list,alphabetical,periodical,\n    \"\"\"\n    if isinstance(sort_method, str):\n        if sort_method not in [\n                \"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\", None\n        ]:\n            raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' is not one of 'x','y','z','alphabetical','periodical'\") # yapf: disable\n        # making individual string so it can work in for loop enumerate below\n        sort_method = [sort_method]\n    elif isinstance(sort_method, list) or isinstance(sort_method, tuple):\n        if len(sort_method) != len(self.species_line):\n            raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' not the same length of amount of species in ABCMolecule\") # yapf: disable\n        for item in sort_method:\n            if isinstance(item, str):\n                item = [item]\n            if not isinstance(item, list) and not isinstance(item, tuple):\n                raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item not correct type\") # yapf: disable\n            if len(item) == 1:\n                if item[0] not in self.species_line:\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line (len(item)=1)\") # yapf: disable\n            elif len(item) == 2:\n                if item[0] not in self.species_line:\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line\") # yapf: disable\n                if item[1] not in [\"x\", \"y\", \"z\", \"None\", None]:\n                    raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item position 1 is not one of type 'x','y','z','None',None (len(item)=2)\") # yapf: disable\n            else:\n                raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list item length &gt; 2\") # yapf: disable\n    else:\n        raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' not correct types\") # yapf: disable\n    if isinstance(ascending, list) or isinstance(ascending, tuple):\n        if not isinstance(sort_method, list) and not isinstance(\n                sort_method, tuple):\n            raise ValueError(\"ABCMolecule.sort() ascending is type list but sortmethod is not type list\") # yapf: disable\n        if len(sort_method) != len(ascending):\n            raise ValueError(\"ABCMolecule.sort() length of ascending list not equivalent to length of sort method\") # yapf: disable\n        if not all([isinstance(item, bool) for item in ascending]):\n            raise ValueError(\"ABCMolecule.sort() ascending list[bool] not all bool type\") # yapf: disable\n    elif not isinstance(ascending, bool):\n        raise ValueError(\"ABCMolecule.sort() ascending bool type not bool type\") # yapf: disable\n    return_atoms: list[ABCCoord] = list()\n    for n, item in enumerate(sort_method):\n        if isinstance(ascending, bool):\n            reverse_bool = False if ascending else True\n        elif isinstance(ascending, list) and len(ascending) == 1:\n            reverse_bool = False if ascending[0] else True\n        elif len(ascending) == len(sort_method):\n            reverse_bool = False if ascending[n] else True\n        else:\n            raise ValueError(\"ABCMolecule.sort() ascending argument is wrong\") # yapf: disable\n        if isinstance(item, list) or isinstance(item, tuple):\n            if len(item) == 1:\n                tobesorted = self.atoms  # for string\n                method = item[0]\n            elif item[0] in self.species_line:\n                tobesorted = self[item[0]].atoms\n                method = item[1]\n            else:\n                raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' is not correct\") # yapf: disable\n        else:  #if isinstance(item, str):\n            if item in self.species_line:\n                tobesorted = self[item].atoms\n                method = \"None\"\n            elif item in [\n                    \"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\",\n                    None\n            ]:\n                # raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list species index 1 is not one of 'x','y','z','alphabetical','periodical','None',None\") # yapf: disable\n                method = item\n                tobesorted = self.atoms\n            else:\n                raise ValueError(\"ABCMolecule.sort() required argument 'sort_method' list species does not contain species\") # yapf: disable\n        if method == \"x\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x[1], reverse=reverse_bool))\n        elif method == \"y\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x[2], reverse=reverse_bool))\n        elif method == \"z\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x[3], reverse=reverse_bool))\n        elif method == \"alphabetical\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x.sp, reverse=reverse_bool))\n        elif method == \"periodical\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: ACCEPTED_ELEMENTS.index(x.sp), reverse=reverse_bool))\n        else:\n            return_atoms.extend(tobesorted)\n    if inplace:\n        self.atoms = return_atoms\n        self.__post_init__()\n    return ABCMolecule(\n        unitcell=self.unitcell,\n        positional=self.positional,\n        atoms=return_atoms,\n        comment_line=self.comment_line,\n        filetype=self.filetype,\n    )\n</code></pre>"},{"location":"reference/#abc-private-functions","title":"ABC Private Functions","text":""},{"location":"reference/#molecule_lib._islatticematrix","title":"<code>molecule_lib._islatticematrix(lattice_list)</code>","text":"<p>Return True if lattice_list is .vasp file lattice matrix, False otherwise.</p> <p>Parameters:</p> <ul> <li> <code>lattice_list</code>             (<code>(list of filelines.split())</code>)         \u2013          <p>Is a list of list of filelines where each string in the file line seperated by a space is its own element in the list. data_list[0] is the contains the first line information of the file and data_list[-1] contains the last line 0 information of the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if lattice_list fufills .vasp file lattice matrix standards.</p> </li> </ul> Notes <p>.vasp file lattice matrix:     -lattice constant is a postive float number.     -lattice matrix is a 3x3 float matrix.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def _islatticematrix(lattice_list: list[list[str]]) -&gt; bool:\n    \"\"\"Return True if lattice_list is .vasp file lattice matrix, False otherwise.\n\n    Parameters\n    ----------\n    lattice_list : (list of filelines.split())\n        Is a list of list of filelines\n        where each string in the file line seperated by a space is its own\n        element in the list. data_list[0] is the contains the first line\n        information of the file and data_list[-1] contains the last line\n        0 information of the file.\n\n    Returns\n    -------\n    bool\n        True if lattice_list fufills .vasp file lattice matrix standards.\n\n    Notes\n    -----\n    .vasp file lattice matrix:\n        -lattice constant is a postive float number.\n        -lattice matrix is a 3x3 float matrix.\n    \"\"\"\n    if len(lattice_list) != 4:\n        return False\n    # lattice constant should not be negative\n    if len(lattice_list[0]) != 1 or lattice_list[0][0].replace(\".\", \"\").isdigit() is False:\n        return False\n    for i in range(1, 4):\n        if len(lattice_list[i]) != 3:\n            return False\n        if all(_isfloatstr(ele) for ele in lattice_list[i]) is False:\n            return False\n    return True\n</code></pre>"},{"location":"reference/#molecule_lib._is3byxfloatmatrix","title":"<code>molecule_lib._is3byxfloatmatrix(num_matrix)</code>","text":"<p>Return True if num_matrix is a 3 by x float matrix, False otherwise.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def _is3byxfloatmatrix(num_matrix: list[list[str]]) -&gt; bool:\n    \"\"\"Return True if num_matrix is a 3 by x float matrix, False otherwise.\"\"\"\n    for i in range(len(num_matrix)):\n        if len(num_matrix[i]) != 3:\n            return False\n        if all(_isfloatstr(ele) for ele in num_matrix[i]) is False:\n            return False\n    return True\n</code></pre>"},{"location":"reference/#molecule_lib._is6byxfloatselectivematrix","title":"<code>molecule_lib._is6byxfloatselectivematrix(sel_matrix)</code>","text":"<p>Return True if sel_matrix is a 6 by x with first 3 data info is float matrix and next 3 is either 'F' or 'T' string, False otherwise.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def _is6byxfloatselectivematrix(sel_matrix: list[list[str]]) -&gt; bool:\n    \"\"\"Return True if sel_matrix is a 6 by x with first 3 data info is float matrix and next 3 is either 'F' or 'T' string, False otherwise.\"\"\"\n    for i in range(len(sel_matrix)):\n        if len(sel_matrix[i]) != 6:\n            return False\n        if (\n            _isfloatstr(sel_matrix[i][0]) is False\n            or _isfloatstr(sel_matrix[i][1]) is False\n            or _isfloatstr(sel_matrix[i][2]) is False\n            or (\"F\" in sel_matrix[i][3] or \"T\" in sel_matrix[i][3]) is False\n            or (\"F\" in sel_matrix[i][4] or \"T\" in sel_matrix[i][4]) is False\n            or (\"F\" in sel_matrix[i][5] or \"T\" in sel_matrix[i][5]) is False\n        ):\n            return False\n    return True\n</code></pre>"},{"location":"reference/#abc-functions","title":"ABC Functions","text":""},{"location":"reference/#molecule_lib.isvasplist","title":"<code>molecule_lib.isvasplist(data_list, extralines=False)</code>","text":"<p>Return True if data list fufills .vasp file standards, False otherwise.</p> <p>Parameters:</p> <ul> <li> <code>data_list</code>             (<code>(list of filelines.split())</code>)         \u2013          <p>Is a list of list of filelines where each string in the file line seperated by a space is its own element in the list. data_list[0] is the contains the first line information of the file and data_list[-1] contains the last line 0 information of the file.</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, if there are extra lines in the file, function returns False. It is quote 'strict' on extra lines if True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if data_list fufills .vasp file standards.</p> </li> </ul> Notes <p>.vasp file standards:     -there is a positive float value for lattice constant     -there is a 3x3 float matrix for lattice matrix     -there is correct species line     -there is list of integers below species line     -there is Selective Dynamics with dynamics info after coord info     -there is Cartesian or Direct with correct coord matrix below</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def isvasplist(data_list: list[list[str]], extralines: bool = False) -&gt; bool:\n    \"\"\"Return True if data list fufills .vasp file standards, False otherwise.\n\n    Parameters\n    ----------\n    data_list : (list of filelines.split())\n        Is a list of list of filelines\n        where each string in the file line seperated by a space is its own\n        element in the list. data_list[0] is the contains the first line\n        information of the file and data_list[-1] contains the last line\n        0 information of the file.\n    extralines: bool, default True\n        If True, if there are extra lines in the file, function returns False.\n        It is quote 'strict' on extra lines if True.\n\n    Returns\n    -------\n    bool\n        True if data_list fufills .vasp file standards.\n\n    Notes\n    -----\n    .vasp file standards:\n        -there is a positive float value for lattice constant\n        -there is a 3x3 float matrix for lattice matrix\n        -there is correct species line\n        -there is list of integers below species line\n        -there is Selective Dynamics with dynamics info after coord info\n        -there is Cartesian or Direct with correct coord matrix below\n    \"\"\"\n    if _islatticematrix(data_list[1:5]) is False:\n        return False\n    if all(ele in ACCEPTED_ELEMENTS for ele in data_list[5]) is False:\n        return False\n    if all(ele.isdecimal() for ele in data_list[6]) is False:\n        return False\n    tot_atom = sum([int(i) for i in data_list[6]])\n    if len(data_list) &lt; tot_atom + 8:\n        return False\n    if \"S\" in data_list[7][0] and (\"C\" in data_list[8][0] or \"D\" in data_list[8][0]):\n        if _is6byxfloatselectivematrix(data_list[9: tot_atom + 9]) is False:\n            return False\n        num_top_lines = 9\n    elif \"C\" in data_list[7][0] or \"D\" in data_list[7][0]:\n        if _is3byxfloatmatrix(data_list[8: tot_atom + 8]) is False:\n            return False\n        num_top_lines = 8\n    else:\n        return False\n    if len(data_list[5]) != len(data_list[6]):\n        return False\n    if not extralines:\n        if (  # TODO!!!! IS THIS NEEDED??????????????????\n            len(data_list) == tot_atom + \\\n                num_top_lines or len(data_list) == tot_atom * \\\n            2 + 1 + num_top_lines\n        ):\n            return True\n        else:\n            return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/#molecule_lib.create_from_vasp_file_data","title":"<code>molecule_lib.create_from_vasp_file_data(file_data, extralines=False)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>file_data</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>description, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def create_from_vasp_file_data(file_data: list[list[str]], extralines: bool = False) -&gt; ABCMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    file_data : list[list[str]]\n        _description_\n    extralines : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n    if not isvasplist(data_list=file_data, extralines=extralines):\n        raise Exception(\"parsererror, not vasplist\")\n    total = int(sum([int(file_data[6][i]) for i in range(len(file_data[6]))]))\n    # if \"S\" in file_data[7][0]:\n    #         init_data = [file_data[i] for i in range(9, total + 9)]\n    #         sp = [\n    #             file_data[5][i]\n    #             for i in range(len(file_data[5]))\n    #             for _ in range(int(file_data[6][i]))\n    #         ]\n    #         selective = [\n    #             SelectiveCoord(file_data[i][3],\n    #                            file_data[i][4], file_data[i][5])\n    #             for i in range(9, len(file_data))\n    #         ]\n    #     else:\n    init_data = [file_data[i] for i in range(8, total + 8)]\n    sp = [file_data[5][i]\n          for i in range(len(file_data[5])) for _ in range(int(file_data[6][i]))]\n    if \"C\" in file_data[7][0] or \"C\" in file_data[8][0]:\n        positional = False\n    else:\n        positional = True\n    atoms = [\n        ABCCoord(\n            sp[i],\n            float(init_data[i][0]),\n            float(init_data[i][1]),\n            float(init_data[i][2])\n        )\n        for i in range(total)\n    ]\n    return ABCMolecule(\n        comment_line=\" \".join(file_data[0]),\n        unitcell=LatticeMatrix(\n            constant=float(file_data[1][0]),\n            vector_1=[float(file_data[2][i]) for i in range(3)],\n            vector_2=[float(file_data[3][i]) for i in range(3)],\n            vector_3=[float(file_data[4][i]) for i in range(3)],\n        ),\n        positional=positional,\n        atoms=atoms,\n        filetype=\".vasp\",\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.read_vasp","title":"<code>molecule_lib.read_vasp(filepath, extralines=False)</code>","text":"<p>Reads .vasp or POSCAR file and returns ABCMolecule instance.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>Filename (if in current working directory) or absolute path or os.path.join(os.getcwd(),'filename.xyz')</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, if there are extra lines in the file, function will not return XYZMolecule instance. It is quote 'strict' on extra lines if True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul> Notes <p>Add selective logic, maybe add a bool to turn it on and off or add it if it doesn't have it.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def read_vasp(filepath: str, extralines: bool = False) -&gt; ABCMolecule:\n    \"\"\"Reads .vasp or POSCAR file and returns ABCMolecule instance.\n\n    Parameters\n    ----------\n    filepath : str\n        Filename (if in current working directory)\n        or absolute path or os.path.join(os.getcwd(),'filename.xyz')\n    extralines: bool, default True\n        If True, if there are extra lines in the file, function will not return XYZMolecule instance.\n        It is quote 'strict' on extra lines if True.\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n\n    Notes\n    -----\n    Add selective logic, maybe add a bool to turn it on and off or add it if it doesn't have it.\n    \"\"\"\n    if type(filepath) != str:\n        raise Exception(\"Filepath not a string\")\n    if os.path.isfile(filepath) is False:\n        raise Exception(\"Filepath does not exist\")\n    with open(filepath, \"r\") as openfile:\n        file_data = [line.split() for line in openfile]\n    return create_from_vasp_file_data(file_data=file_data, extralines=extralines)\n</code></pre>"},{"location":"reference/#xyz-no-unitcell-molecule-section","title":"XYZ (No Unitcell) Molecule Section","text":""},{"location":"reference/#molecule_lib.XYZCoord","title":"<code>molecule_lib.XYZCoord</code>","text":"<p>Dataclass for atomic coordinates for use in XYZMolecule class.</p> <p>Parameters:</p> <ul> <li> <code>sp</code>             (<code>str</code>)         \u2013          <p>Species of atom.</p> </li> <li> <code>x</code>             (<code>float</code>)         \u2013          <p>x coordinate position of atom.</p> </li> <li> <code>y</code>             (<code>float</code>)         \u2013          <p>y coordinate position of atom.</p> </li> <li> <code>z</code>             (<code>float</code>)         \u2013          <p>z coordinate position of atom.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>XYZCoord</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>class XYZCoord:\n    \"\"\"Dataclass for atomic coordinates for use in XYZMolecule class.\n\n    Parameters\n    ----------\n    sp : str\n        Species of atom.\n    x : float\n        x coordinate position of atom.\n    y : float\n        y coordinate position of atom.\n    z : float\n        z coordinate position of atom.\n\n    Returns\n    -------\n    XYZCoord\n        _description_\n    \"\"\"\n\n    def __init__(self, sp: str, x: float, y: float, z: float) -&gt; None:\n        if sp not in ACCEPTED_ELEMENTS:\n            raise ValueError(f\"XYZCoord.__init__() required postional argument 'sp' is not an accepted species string\") # yapf: disable\n        if type(x) not in [int, float]:\n            raise ValueError(f\"XYZCoord.__init__() required positional argument 'x' is not a number\") # yapf: disable\n        if type(y) not in [int, float]:\n            raise ValueError(f\"XYZCoord.__init__() required positional argument 'y' is not a number\") # yapf: disable\n        if type(z) not in [int, float]:\n            raise ValueError(f\"XYZCoord.__init__() required positional argument 'z' is not a number\") # yapf: disable\n        self.sp: str = sp\n        self.x: float = x\n        self.y: float = y\n        self.z: float = z\n        return None\n\n    def __repr__(self) -&gt; str:\n        # \"\"\"\n        # Notes\n        # -----\n        # when you are in kernel and run object with enter\n        # \"\"\"\n        return self.__str__()\n\n    def __str__(self) -&gt; str:\n        # \"\"\"\n        # Notes\n        # -----\n        # by using str() or print()\n        # also might need to create XYZCoord.line() method because this return was used in editor i think\n        # return f\"{self.sp:&gt;4} {self.x:&gt;{Lc}.{Fc}f}{self.y:&gt;{Lc}.{Fc}f}{self.z:&gt;{Lc}.{Fc}f}\"\n        # \"\"\"\n        return f\"XYZCoord(sp='{self.sp}', x={self.x}, y={self.y}, z={self.z})\"\n\n    def __len__(self) -&gt; int:\n        # \"\"\"\n        # Notes\n        # -----\n        # needed for something... i think it was indexing but not 100% positive\n        # \"\"\"\n        return 1\n\n    def __getitem__(self, index: int) -&gt; float:\n        if index == 1:\n            return self.x\n        elif index == 2:\n            return self.y\n        elif index == 3:\n            return self.z\n        else:\n            raise IndexError(\"XYZCoord.__getitem__() Index out of list.\")\n\n    def line(self) -&gt; str:\n        return f\"{self.sp:&gt;4} {self.x:&gt;{Lc}.{Fc}f}{self.y:&gt;{Lc}.{Fc}f}{self.z:&gt;{Lc}.{Fc}f}\"\n</code></pre>"},{"location":"reference/#molecule_lib.XYZCoord.line","title":"<code>line()</code>","text":"Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def line(self) -&gt; str:\n    return f\"{self.sp:&gt;4} {self.x:&gt;{Lc}.{Fc}f}{self.y:&gt;{Lc}.{Fc}f}{self.z:&gt;{Lc}.{Fc}f}\"\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule","title":"<code>molecule_lib.XYZMolecule</code>","text":"<p>Class for xyz molecule object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>list[XYZCoord]</code>)         \u2013          <p>description</p> </li> <li> <code>comment_line</code>             (<code>str</code>, default:                 <code>is \" \"</code> )         \u2013          <p>description</p> </li> <li> <code>filetype</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>XYZMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>class XYZMolecule:\n    \"\"\"Class for xyz molecule object.\n\n    Parameters\n    ----------\n    atoms : list[XYZCoord]\n        _description_\n    comment_line : str, default is \" \"\n        _description_\n    filetype: str\n        __description__\n\n    Returns\n    -------\n    XYZMolecule\n        _description_\n    \"\"\"\n\n    def __init__(self, atoms: list[XYZCoord], comment_line: str = \" \", filetype: str=\"\") -&gt; None:\n        for n, item in enumerate(atoms):\n            if not isinstance(item, XYZCoord):\n                raise ValueError(f\"XYZMolecule.__init__() index {n} of atoms is not type XYZCoord; item = {item}\") # yapf: disable\n        self.atoms: list[XYZCoord] = atoms\n        self.comment_line: str = str(comment_line)\n        self.filetype: str = str(filetype)\n        self.__post_init__()\n        return None\n\n    def __post_init__(self) -&gt; None:\n        self.coord_type = XYZCoord\n        self.species_line: list[str] = list()\n        self.species_amount: list[str] = list()\n        _ = \"PL@C3H0LD3R\"\n        for atom in self.atoms:\n            if atom.sp == _:\n                self.species_amount[-1] = str(1 + int(self.species_amount[-1]))\n            else:\n                self.species_line.append(atom.sp)\n                self.species_amount.append(\"1\")\n                _ = atom.sp\n        self.total = sum([int(num) for num in self.species_amount])\n        return None\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Notes\n        -----\n        by using str() or print()\n        \"\"\"\n        return f\"XYZMolecule(atoms={self.atoms}, comment_line='{self.comment_line}')\"\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    def __add__(self, item: XYZMolecule) -&gt; XYZMolecule:\n        if not isinstance(item, XYZMolecule):\n            raise ValueError(\"XYZMolecule.__add__() can only add type XYZMolecule\") # yapf: disable\n        return self.append(new_coords=item.atoms)\n\n    def __len__(self) -&gt; int:\n        return len(self.atoms)\n\n    def __getitem__(self, index: MolIndex) -&gt; XYZMolecule:\n        \"\"\"\n        Notes\n        -----\n        index type is int | str | list[int] | list[str]\n        \"\"\"\n        if type(index) in [int, str]:\n            index = str(index)\n            if index.replace(\"-\", \"\").isdecimal():\n                if -len(self.atoms) &lt;= int(index) &lt;= -1:\n                    return XYZMolecule(atoms=[self.atoms[int(index)]], comment_line=self.comment_line, filetype=self.filetype,)\n                elif len(self.atoms) &gt;= int(index) &gt;= 1:\n                    return XYZMolecule(atoms=[self.atoms[int(index) - 1]], comment_line=self.comment_line, filetype=self.filetype,)\n                else:\n                    raise IndexError(f\"XYZMolecule.__getitem__() int is out of range of len(self.atoms) or is zero\") # yapf: disable\n            elif index in self.species_line:\n                return XYZMolecule(\n                    atoms=[item for item in self.atoms if item.sp == index],\n                    comment_line=self.comment_line,\n                    filetype=self.filetype,\n                )\n            else:\n                return XYZMolecule(\n                    atoms=[self.atoms[self._get_molden_index(index)]],\n                    comment_line=self.comment_line,\n                    filetype=self.filetype,\n                )\n        elif type(index) is list:\n            return_atoms: list[XYZCoord] = list()\n            for item in [str(ele) for ele in index]:\n                if item.replace(\"-\", \"\").isdecimal():\n                    if -len(self.atoms) &lt;= int(item) &lt;= -1:\n                        return_atoms.append(self.atoms[int(item)])\n                    elif len(self.atoms) &gt;= int(item) &gt;= 1:\n                        return_atoms.append(self.atoms[int(item) - 1])\n                    else:\n                        raise IndexError(f\"XYZMolecule.__getitem__() int is out of range of len(self.atoms)\") # yapf: disable\n                elif item in self.species_line:\n                    return_atoms.extend(\n                        [ele for ele in self.atoms if ele.sp == item])\n                else:\n                    return_atoms.append(\n                        self.atoms[self._get_molden_index(item)])\n            return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n        else:\n            raise IndexError(f\"XYZMolecule.__getitem__() not valid index\")\n\n    def _get_molden_index(self, index: MolIndex) -&gt; int:\n        if type(index) != str:\n            raise IndexError(\"XYZMolecule._get_molden_index() index type not correct\") # yapf: disable\n        _n1 = \"\"\n        _a1 = \"\"\n        for item in index[::-1]:\n            if item.isdecimal():\n                _n1 += item\n            else:\n                _a1 += item\n        _n2 = _n1[::-1]\n        if _n2 == \"\":\n            raise IndexError(\"XYZMolecule._get_molden_index() no # after\")\n        _a2 = _a1[::-1]\n        if index == _a2 + _n2:\n            _n3 = int(_n2)\n            if _a2 not in self.species_line:\n                raise IndexError(\"XYZMolecule._get_molden_index() Sp not in self.speciesline\") # yapf: disable\n            if int(self.species_amount[self.species_line.index(_a2)]) &gt;= _n3 &gt;= 1:\n                return self.atoms.index([item for item in self.atoms if item.sp == _a2][_n3 - 1])\n            else:\n                raise IndexError(\"XYZMolecule._get_molden_index() # is too large or zero\") # yapf: disable\n        else:\n            raise IndexError(\"XYZMolecule._get_molden_index() Sp# out of order\") # yapf: disable\n\n    def __setitem__(self, index: int | str, new_item: XYZCoord) -&gt; None:\n        if type(index) not in [int, str]:\n            raise ValueError(\"XYZMolecule.__setitem__() index must be of type int or str\") # yapf: disable\n        if isinstance(new_item, XYZCoord):\n            self.atoms[self.atoms.index(\n                self.__getitem__(index).atoms[0])] = new_item\n            self.__post_init__()\n            return None\n        else:\n            raise ValueError(\"XYZMolecule.__setitem__() Value assignment must be type XYZCoord\") # yapf: disable\n\n    def add_coords(\n        self,\n        molecule: XYZMolecule,\n        axis: str | int,\n        absorbent_reference: str | XYZCoord,\n        surface_reference: str | XYZCoord,\n        dist: float,\n        inplace: bool = False,\n    ) -&gt; XYZMolecule:\n        \"\"\"Add a new Molecule object to the current XYZMolecule object very precisely.\n\n        Parameters\n        ----------\n        molecule : XYZMolecule\n            _description_\n        axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n            Placement of new molecule will be in direction of axis.\n        absorbent_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n            _description_\n        surface_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n            _description_\n        dist : float\n            sign of float determines what direction the new molecule is placed.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        XYZMolecule\n            XYZMolecule with new atoms added.\n\n        Notes\n        ------\n        Need to add CoordType logic.\n        Need to add ABCMolecule logic.\n        NEED TO ADD absorbent/surface reference can of type coord also probably need coord protocol\n        \"\"\"\n        if axis not in [\"x\", \"y\", \"z\"] and axis not in [0, 1, 2]:\n            raise ValueError(f\"XYZMolecule.add_coords() required argument 'angle' is not 'x' or 'y' or 'z' or 1 or 2 or 3 \") # yapf: disable\n        match axis:\n            case \"x\":\n                axis_int = 0\n            case \"y\":\n                axis_int = 1\n            case \"z\":\n                axis_int = 2\n            case _:\n                axis_int = int(axis)\n        # needed to not append to memory and return only changed object\n        combined_atoms = copy.copy(self.atoms)\n        sur_centroids = self.get_centroid()\n        sur_mod = [sur_centroids[0], sur_centroids[1], sur_centroids[2]]\n        x_import_centroid, y_import_centroid, z_import_centroid = molecule.get_centroid()\n        abs_centroids = [x_import_centroid,\n                         y_import_centroid, z_import_centroid]\n        x_import_list = [float(coord[1]) for coord in molecule.atoms]\n        y_import_list = [float(coord[2]) for coord in molecule.atoms]\n        z_import_list = [float(coord[3]) for coord in molecule.atoms]\n        abs_lists = (x_import_list, y_import_list, z_import_list)\n        x_curr_list = [float(coord[1]) for coord in self.atoms]\n        y_curr_list = [float(coord[2]) for coord in self.atoms]\n        z_curr_list = [float(coord[3]) for coord in self.atoms]\n        sur_lists = (x_curr_list, y_curr_list, z_curr_list)\n        # finding absorbent values\n        if absorbent_reference == \"Centroid\":\n            abs_mod = abs_centroids\n        elif absorbent_reference == \"Top\" or absorbent_reference == \"Bottom\":\n            abs_mod = abs_centroids\n            if absorbent_reference == \"Top\":\n                sort_func = max\n            else:  # if absorbent_reference == \"Bottom\":\n                sort_func = min\n            abs_mod[axis_int] = sort_func(abs_lists[axis_int])\n        else:\n            abs_mod = [0.0, 0.0, 0.0]\n        # finding surface values now\n        if isinstance(surface_reference, XYZCoord):\n            pass\n        elif isinstance(surface_reference, str):\n            pass\n        else:\n            raise ValueError(\"XYZMolecule.add_coords() required argument 'surface_reference' is not type str or XYZCoord.\") # yapf: disable\n        if isinstance(surface_reference, XYZCoord):\n            pass\n        elif surface_reference == \"Centroid\":\n            sur_mod = sur_centroids\n        elif surface_reference == \"(0.5,0.5,0.5)\":\n            sur_mod = [0.5, 0.5, 0.5]\n        elif surface_reference == \"Top\" or surface_reference == \"Bottom\":\n            if surface_reference == \"Top\":\n                sort_func = max\n            # if surface_reference == ABSORBENT_OPTIONS['starting_surface_list'][1]:\n            else:\n                sort_func = min\n            sur_mod[axis_int] = sort_func(sur_lists[axis_int])\n        elif \"Most positive \" in surface_reference or \"Most negative\" in surface_reference:\n            species = surface_reference[14:]\n            if \"Most positive \" in surface_reference:\n                sort_func = max\n            else:  # if \"Most negative\" in surface_reference:\n                sort_func = min\n            species_import_list = [float(coord[axis_int + 1])\n                                   for coord in self.atoms if coord.sp == species]\n            sur_mod[axis_int] = sort_func(species_import_list)\n        else:  # necessary for add atom\n            sur_mod = [0, 0, 0]  # if surface_reference == 'origin'\n        # math for finding displacement distanceance\n        distance = [0.0, 0.0, 0.0]\n        distance[axis_int] = dist\n        x_mod = sur_mod[0] - abs_mod[0] + distance[0]\n        y_mod = sur_mod[1] - abs_mod[1] + distance[1]\n        z_mod = sur_mod[2] - abs_mod[2] + distance[2]\n        for ele in molecule.atoms:\n            combined_atoms.append(XYZCoord(ele.sp, float(\n                ele[1]) + x_mod, float(ele[2]) + y_mod, float(ele[3]) + z_mod))\n        if inplace:\n            self.atoms = combined_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=combined_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n\n    def append(self, new_coords: XYZCoord | list[XYZCoord], inplace: bool = False) -&gt; XYZMolecule:\n        \"\"\"To add coords to the current self.atoms attribute.\n\n        Parameters\n        ----------\n        new_coords : XYZCoord or list[XYZCoord]\n            List of new coords to add to new object.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        XYZMolecule\n            _description_\n        \"\"\"\n        if not isinstance(new_coords, list):\n            new_coords = [new_coords]\n        for n, item in enumerate(new_coords):\n            if not isinstance(item, XYZCoord):\n                raise ValueError(f\"XYZMolecule.__init__() index {n} of atoms is not type XYZCoord; item = {item}\") # yapf: disable\n        new_atoms = copy.copy(self.atoms)\n        new_atoms.extend(new_coords)\n        if inplace:\n            self.atoms = new_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=new_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n\n    def convert(self, lattice_matrix: LatticeMatrix, positional: bool = True) -&gt; ABCMolecule:\n        \"\"\"Converts XYZMolecule instance to ABCMolecule.\n\n        Parameters\n        ----------\n        lattice_matrix : LatticeMatrix\n            Instance of LatticeMatrix dataclass needed for ABCMolecule class.\n        positional : bool, default True\n            If True, XYZ cartesian coordinates will convert to positional coordinates. If False, ABCMolecule will contain cartesian coordinates.\n\n        Returns\n        -------\n        ABCMolecule\n            _description_\n        \"\"\"\n        if positional:\n            alp, bet, gam = lattice_matrix.getanglesrad()\n            a, b, c = lattice_matrix.getabc()\n            A = [\n                [\n                    csc(bet) / (a * np.sqrt(1 - (cot(alp) * cot(bet) - csc(alp) * csc(bet) * cos(gam)) ** 2)),\n                    0,\n                    0,\n                ],\n                [\n                    ((csc(alp) ** 2) * csc(bet) * (cos(alp) * cos(bet) - cos(gam))) / (b * np.sqrt(1 - (cot(alp) * cot(bet) - csc(alp) * csc(bet) * cos(gam)) ** 2)),\n                    csc(alp) / b,\n                    0,\n                ],\n                [\n                    (csc(alp) * ((cot(alp) * csc(bet) * cos(gam)) - (csc(alp) * cot(bet)))) / (c * np.sqrt(1 - (cot(alp) * cot(bet) - csc(alp) * csc(bet) * cos(gam)) ** 2)),\n                    (-cot(alp)) / c,\n                    1 / c,\n                ],\n            ]\n            convert_atoms: list[ABCCoord] = list()\n            for atom in self.atoms:\n                f = np.matrix([[atom.x], [atom.y], [atom.z]])\n                r = np.dot(A, f)\n                convert_atoms.append(\n                    ABCCoord(atom.sp, float(r[0]), float(r[1]), float(r[2])))\n            return ABCMolecule(\n                comment_line=self.comment_line,\n                atoms=convert_atoms,\n                unitcell=lattice_matrix,\n                positional=positional,\n                filetype=self.filetype,\n            )\n        else:\n            return ABCMolecule(\n                comment_line=self.comment_line,\n                atoms=[ABCCoord(coord.sp, coord.x, coord.y, coord.z) for coord in self.atoms],\n                unitcell=lattice_matrix,\n                positional=positional,\n                filetype=self.filetype,\n            )\n\n    def delete(self, index: MolIndex, inplace: bool = False) -&gt; XYZMolecule:\n        \"\"\"Delete INDEXED atoms in XYZMolecule.\n\n        Parameters\n        ----------\n        index : MolIndex\n            _description_\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        XYZMolecule or None\n            XYZMolecule with selected atoms deleted or None if inplace=True.\n        \"\"\"\n        saving_atoms: list[XYZCoord] = list()\n        del_ints: list[int] = list()\n        if type(index) != list:\n            # not exactly sure why but good theres a small amount of type ignores for each molecule class\n            index = [index]  # type: ignore s\n        for item in index:  # type: ignore\n            for ele in self[item].atoms:\n                del_ints.append(self.atoms.index(ele))\n        saving_atoms = [self.atoms[i]\n                        for i in range(len(self.atoms)) if not i in del_ints]\n        if inplace:\n            self.atoms = saving_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=saving_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n\n    def format(self, endline: str = \" \", filetype: str = \".xyz\") -&gt; list[str]:\n        \"\"\"Returns formatted text for textbox or filewrite.\n\n        Parameters\n        ----------\n        endline : str, default \" \"\n            Endline string for each file line.\n\n        Returns\n        -------\n        list[str]\n            list of strings for xyz format with endline str as last character in string.\n\n        Notes\n        -----\n        Can replace text.append self.atoms with XYZCoord.line()\n        \"\"\"\n        text: list[str] = list()\n        if filetype == \".xyz\":\n            text.append(f\"{self.total}\" + endline)\n            text.append(f\"{self.comment_line}\" + endline)\n            for i in range(len(self.atoms)):\n                text.append(f\"{self.atoms[i].sp:2}{self.atoms[i].x:&gt;{Lx}.{Fx}f}{self.atoms[i].y:&gt;{Lx}.{Fx}f}{self.atoms[i].z:&gt;{Lx}.{Fx}f}\" + endline)\n            return text\n        elif filetype == \".turbomole\":\n            text.append(\"$coord\" + endline)\n            for i in range(len(self.atoms)):\n                text.append(f\"{'': &lt;8}{self.atoms[i].x:&gt;{Lx}.{Fx}f}{self.atoms[i].y:&gt;{Lx}.{Fx}f}{self.atoms[i].z:&gt;{Lx}.{Fx}f}{'': &lt;4}{self.atoms[i].sp.lower():2}\" + endline)\n            text.append(\"$end\" + endline)\n            return text\n        else:\n            raise ValueError(\"XYZMolecule.format() optional argument 'filetype' is not '.xyz' or '.turbomole'\") # yapf: disable\n\n    def get_centroid(self) -&gt; tuple[float, float, float]:\n        \"\"\"Returns 3d centroid of XYZMolecule atoms.\n\n        Returns\n        -------\n        tuple[float,float,float]\n            Tuple of (x_centroid,y_centroid,z_centroid) in units Angstroms.\n        \"\"\"\n        x_list = [coord.x for coord in self.atoms]\n        y_list = [coord.y for coord in self.atoms]\n        z_list = [coord.z for coord in self.atoms]\n        x_centroid = sum(x_list) / len(x_list)\n        y_centroid = sum(y_list) / len(y_list)\n        z_centroid = sum(z_list) / len(z_list)\n        return (x_centroid, y_centroid, z_centroid)\n\n    def info(self) -&gt; None:\n        \"\"\"Prints XYZMolecule current attribute information to terminal.\"\"\"\n        species_key = [x for i, x in enumerate(\n            self.species_line) if self.species_line.index(x) == i]\n        amount_dict = {sp: \"0\" for sp in species_key}\n        for ele, amt in zip(self.species_line, self.species_amount):\n            curr_value = amount_dict[ele]\n            new_value = int(amt) + int(curr_value)\n            amount_dict[ele] = str(new_value)\n        print(f\"type: XYZMolecule\\nfiletype: {self.filetype}\\ntotal atoms: {self.total}\\nspecies info: {amount_dict}\\ncomment line: '{self.comment_line}'\") # yapf: disable\n        return None\n\n    def manipulate(self, index: MolIndex, func: str, inplace: bool = False, *args: Any, **kwargs: Any) -&gt; XYZMolecule:\n        \"\"\"Rotate or move only INDEXED atoms in XYZMolecule.\n\n        Parameters\n        ----------\n        index : MolIndex\n            _description_\n        func : \"{'move' or 'rotate'}\"\n            XYZMolecule method you want to execute on the indexed atoms.\n        inplace : bool, default False\n            If True, perform operation in-place.\n        *args,**kwargs\n            Needed for the chosen function 'move' or 'rotate'.\n\n        Returns\n        -------\n        XYZMolecule or None\n            XYZMolecule with all atoms moved or None if inplace=True.\n        \"\"\"\n        i_list: list[int] = list()\n        moving_atoms: list[XYZCoord] = list()\n        if type(index) != list:\n            index = [index]  # type: ignore\n        for item in index:  # type: ignore\n            for ele in self[item].atoms:\n                i_list.append(self.atoms.index(ele))\n                moving_atoms.append(ele)\n        moving_mol = XYZMolecule(atoms=moving_atoms)\n        if func == \"move\":\n            new_mol = moving_mol.move(*args, **kwargs)\n        elif func == \"rotate\":\n            new_mol = moving_mol.rotate(*args, **kwargs)\n        else:\n            raise ValueError(\"XYZMolecule.manipulate() required argument 'func' not 'move' or 'rotate'\") # yapf: disable\n        new_atoms = self.atoms\n        for n, ele in zip(i_list, new_mol.atoms):\n            new_atoms[n] = ele\n        if inplace:\n            self.atoms = new_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=new_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n\n    def move(self, x: float = 0, y: float = 0, z: float = 0, inplace: bool = False) -&gt; XYZMolecule:\n        \"\"\"Move ALL atoms in designated directions.\n\n        Parameters\n        ----------\n        x : float, default 0.0\n            Move coord in x direction by float amount.\n        y : float, default 0.0\n            Move coord in y direction by float amount.\n        z : float, default 0.0\n            Move coord in z direction by float amount.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        XYZMolecule or None\n            XYZMolecule with all atoms moved or None if inplace=True.\n        \"\"\"\n        if type(x) not in [int, float]:\n            raise ValueError(f\"XYZMolecule.move() optional argument 'x' is not a number\") # yapf: disable\n        if type(y) not in [int, float]:\n            raise ValueError(f\"XYZMolecule.move() optional argument 'y' is not a number\") # yapf: disable\n        if type(z) not in [int, float]:\n            raise ValueError(f\"XYZMolecule.move() optional argument 'z' is not a number\") # yapf: disable\n        if not isinstance(inplace, bool):\n            raise ValueError(\"XYZMolecule.move() optional argument 'inplace' is not a bool\") # yapf: disable\n        return_atoms: list[XYZCoord] = list()\n        for coord in self.atoms:\n            sp = coord.sp\n            x_old = coord.x\n            y_old = coord.y\n            z_old = coord.z\n            return_atoms.append(\n                XYZCoord(sp=sp, x=x_old + x, y=y_old + y, z=z_old + z))\n        if inplace:\n            self.atoms = return_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n\n    def printt(self) -&gt; None:\n        \"\"\"Prints save file text to terminal.\"\"\"\n        for line in self.format(endline=\" \"):\n            print(line)\n\n    def rotate(\n        self,\n        axis: str,\n        angle: float,\n        unit: str = \"deg\",\n        about_centroid: bool = True,\n        inplace: bool = False,\n    ) -&gt; XYZMolecule:\n        \"\"\"Rotate ALL atoms about designated axis.\n\n        Parameters\n        ----------\n        axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n            Parallel axis of rotation.\n        angle : float\n            Angle of rotation.\n        unit : \"deg\" or \"rad\", default \"deg\"\n            Unit of angle argument.\n        about_centroid : bool, default True\n            If True, rotation occurs about the centroid.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        XYZMolecule or None\n            XYZMolecule with all atoms moved or None if inplace=True.\n        \"\"\"\n        if axis not in [\"x\", \"y\", \"z\"]:\n            raise ValueError(f\"XYZMolecule.move() required argument 'angle' is not 'x' or 'y' or 'z' \") # yapf: disable\n        if type(angle) not in [int, float]:\n            raise ValueError(f\"XYZMolecule.rotate() required argument 'angle' is not a number\") # yapf: disable\n        if unit not in [\"deg\", \"rad\"]:\n            raise ValueError(f\"XYZMolecule.rotate() required argument 'unit' is not 'deg' or 'rad'\") # yapf: disable\n        if not isinstance(inplace, bool):\n            raise ValueError(\"XYZMolecule.rotate() optional argument 'inplace' is not a bool\") # yapf: disable\n        if unit == \"deg\":\n            angle *= pi / 180\n        match axis:\n            case \"x\":\n\n                def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n                    return x, y * cos(angle) - z * sin(angle), y * sin(angle) + z * cos(angle)\n\n            case \"y\":\n\n                def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n                    return x * cos(angle) + z * sin(angle), y, z * cos(angle) - x * sin(angle)\n\n            case \"z\":\n\n                def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n                    return x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle), z\n\n            case _:\n\n                raise Exception(\"XYZMolecule.rotate() required argument 'axis' is not 'x','y', or 'z'\") # yapf: disable\n\n        return_atoms: list[XYZCoord] = list()\n        if about_centroid:\n            x_cent, y_cent, z_cent = self.get_centroid()\n        else:\n            x_cent = y_cent = z_cent = 0.0\n        for coord in self.atoms:\n            rot_x, rot_y, rot_z = rotation(float(coord.x) - x_cent, float(coord.y) - y_cent, float(coord.z) - z_cent)\n            return_atoms.append(XYZCoord(sp=coord.sp, x=rot_x + x_cent, y=rot_y + y_cent, z=rot_z + z_cent))\n        if inplace:\n            self.atoms = return_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n\n    def save(self, filename: str, filetype: str = \".xyz\") -&gt; None:\n        \"\"\"Save XYZMolecule instance to given filename in current working directory.\n\n        Parameters\n        ----------\n        filename : str\n            Name you want the saved file to be.\n\n        Returns\n        -------\n        filename.xyz in current working directory.\n        \"\"\"\n        if filetype not in [\".xyz\",\".turbomole\"]:\n            raise ValueError(\"XYZMolecule.save() optional argument 'filetype' is not '.xyz' or '.turbomole'\") # yapf: disable\n        with open(os.path.join(os.getcwd(), filename), \"w\") as openfile:\n            for line in self.format(endline=\"\\n\", filetype=filetype):\n                openfile.writelines(line)\n\n    def sort(\n        self,\n        sort_method: str | list[str] | list[list[str]],\n        ascending: bool | list[bool] = True,\n        inplace: bool = False,\n    ) -&gt; XYZMolecule | None:\n        \"\"\"Sort the atoms in Molecule instance by position, species, alphabetical or atomic number.\n\n        Parameters\n        ----------\n        sort_method : str | list[str] | list[list[str]]\n            Method given by which the atoms will be sorted.\n                - if sort_method is 'x' the atoms will be sorted by their x coordinate.\n                - if sort_method is 'y' the atoms will be sorted by their y coordinate.\n                - if sort_method is 'z' the atoms will be sorted by their z coordinate.\n                - if sort_method is 'alphabetical' the atoms will be sorted in alphabetical order by their species.\n                - if sort_method is 'periodical' the atoms will be sorted by their atomic number.\n            You can also supply a list of lists with position 0 being species and position 1 being 'x','y','z', or None.\n                This will sort the coordinates by species then by the method provided for each species,\n                you can also add a list of bool for ascending values that will correspond to each species chosen method.\n            You can also supply a list of species and it will be reordered to the given order.\n        ascending : bool or list of bool, default True\n            Sort ascending vs. descending. Specify list for multiple sort orders (as described above). If this is a list of bools, must match the length of sort_method.\n        inplace : bool, default False\n            If True, perform operation in-place.\n\n        Returns\n        -------\n        XYZMolecule or None\n            XYZMolecule with all atoms moved or None if inplace=True.\n\n        Notes\n        -----\n        sort method +x,-x,+y,-y,+z,-z,species,sp list,alphabetical,periodical,\n        \"\"\"\n        if isinstance(sort_method, str):\n            if sort_method not in [\"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\", None]:\n                raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' is not one of 'x','y','z','alphabetical','periodical'\") # yapf: disable\n            # making individual string so it can work in for loop enumerate below\n            sort_method = [sort_method]\n        elif isinstance(sort_method, list) or isinstance(sort_method, tuple):\n            if len(sort_method) != len(self.species_line):\n                raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' not the same length of amount of species in XYZMolecule\") # yapf: disable\n            for item in sort_method:\n                if isinstance(item, str):\n                    item = [item]\n                if not isinstance(item, list) and not isinstance(item, tuple):\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item not correct type\") # yapf: disable\n                if len(item) == 1:\n                    if item[0] not in self.species_line:\n                        raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line (len(item)=1)\") # yapf: disable\n                elif len(item) == 2:\n                    if item[0] not in self.species_line:\n                        raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line\") # yapf: disable\n                    if item[1] not in [\"x\", \"y\", \"z\", \"None\", None]:\n                        raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item position 1 is not one of type 'x','y','z','None',None (len(item)=2)\") # yapf: disable\n                else:\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item length &gt; 2\") # yapf: disable\n        else:\n            raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' not correct types\") # yapf: disable\n        if isinstance(ascending, list) or isinstance(ascending, tuple):\n            if not isinstance(sort_method, list) and not isinstance(sort_method, tuple):\n                raise ValueError(\"XYZMolecule.sort() ascending is type list but sortmethod is not type list\") # yapf: disable\n            if len(sort_method) != len(ascending):\n                raise ValueError(\"XYZMolecule.sort() length of ascending list not equivalent to length of sort method\") # yapf: disable\n            if not all([isinstance(item, bool) for item in ascending]):\n                raise ValueError(\"XYZMolecule.sort() ascending list[bool] not all bool type\") # yapf: disable\n        elif not isinstance(ascending, bool):\n            raise ValueError(\"XYZMolecule.sort() ascending bool type not bool type\") # yapf: disable\n        return_atoms: list[XYZCoord] = list()\n        for n, item in enumerate(sort_method):\n            if isinstance(ascending, bool):\n                reverse_bool = False if ascending else True\n            elif isinstance(ascending, list) and len(ascending) == 1:\n                reverse_bool = False if ascending[0] else True\n            elif len(ascending) == len(sort_method):\n                reverse_bool = False if ascending[n] else True\n            else:\n                raise ValueError(\"XYZMolecule.sort() ascending argument is wrong\") # yapf: disable\n            if isinstance(item, list) or isinstance(item, tuple):\n                if len(item) == 1:\n                    tobesorted = self.atoms  # for string\n                    method = item[0]\n                elif item[0] in self.species_line:\n                    tobesorted = self[item[0]].atoms\n                    method = item[1]\n                else:\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' is not correct\") # yapf: disable\n            else: #if isinstance(item, str):\n                if item in self.species_line:\n                    tobesorted = self[item].atoms\n                    method = \"None\"\n                elif item in [\"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\", None]:\n                    # raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list species index 1 is not one of 'x','y','z','alphabetical','periodical','None',None\") # yapf: disable\n                    method = item\n                    tobesorted = self.atoms\n                else:\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list species does not contain species\") # yapf: disable\n            if method == \"x\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x[1], reverse=reverse_bool))\n            elif method == \"y\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x[2], reverse=reverse_bool))\n            elif method == \"z\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x[3], reverse=reverse_bool))\n            elif method == \"alphabetical\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: x.sp, reverse=reverse_bool))\n            elif method == \"periodical\":\n                return_atoms.extend(sorted(tobesorted, key=lambda x: ACCEPTED_ELEMENTS.index(x.sp), reverse=reverse_bool))\n            else:\n                return_atoms.extend(tobesorted)\n        if inplace:\n            self.atoms = return_atoms\n            self.__post_init__()\n        return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.add_coords","title":"<code>add_coords(molecule, axis, absorbent_reference, surface_reference, dist, inplace=False)</code>","text":"<p>Add a new Molecule object to the current XYZMolecule object very precisely.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.add_coords--parameters","title":"Parameters","text":"<p>molecule : XYZMolecule     description axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"     Placement of new molecule will be in direction of axis. absorbent_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"     description surface_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"     description dist : float     sign of float determines what direction the new molecule is placed. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.add_coords--returns","title":"Returns","text":"<p>XYZMolecule     XYZMolecule with new atoms added.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.add_coords--notes","title":"Notes","text":"<p>Need to add CoordType logic. Need to add ABCMolecule logic. NEED TO ADD absorbent/surface reference can of type coord also probably need coord protocol</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def add_coords(\n    self,\n    molecule: XYZMolecule,\n    axis: str | int,\n    absorbent_reference: str | XYZCoord,\n    surface_reference: str | XYZCoord,\n    dist: float,\n    inplace: bool = False,\n) -&gt; XYZMolecule:\n    \"\"\"Add a new Molecule object to the current XYZMolecule object very precisely.\n\n    Parameters\n    ----------\n    molecule : XYZMolecule\n        _description_\n    axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n        Placement of new molecule will be in direction of axis.\n    absorbent_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n        _description_\n    surface_reference : \"{'Top' or 'Centroid' or 'Bottom' or 'Most postive Sp' or 'Most negative Sp' or CoordType}\"\n        _description_\n    dist : float\n        sign of float determines what direction the new molecule is placed.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    XYZMolecule\n        XYZMolecule with new atoms added.\n\n    Notes\n    ------\n    Need to add CoordType logic.\n    Need to add ABCMolecule logic.\n    NEED TO ADD absorbent/surface reference can of type coord also probably need coord protocol\n    \"\"\"\n    if axis not in [\"x\", \"y\", \"z\"] and axis not in [0, 1, 2]:\n        raise ValueError(f\"XYZMolecule.add_coords() required argument 'angle' is not 'x' or 'y' or 'z' or 1 or 2 or 3 \") # yapf: disable\n    match axis:\n        case \"x\":\n            axis_int = 0\n        case \"y\":\n            axis_int = 1\n        case \"z\":\n            axis_int = 2\n        case _:\n            axis_int = int(axis)\n    # needed to not append to memory and return only changed object\n    combined_atoms = copy.copy(self.atoms)\n    sur_centroids = self.get_centroid()\n    sur_mod = [sur_centroids[0], sur_centroids[1], sur_centroids[2]]\n    x_import_centroid, y_import_centroid, z_import_centroid = molecule.get_centroid()\n    abs_centroids = [x_import_centroid,\n                     y_import_centroid, z_import_centroid]\n    x_import_list = [float(coord[1]) for coord in molecule.atoms]\n    y_import_list = [float(coord[2]) for coord in molecule.atoms]\n    z_import_list = [float(coord[3]) for coord in molecule.atoms]\n    abs_lists = (x_import_list, y_import_list, z_import_list)\n    x_curr_list = [float(coord[1]) for coord in self.atoms]\n    y_curr_list = [float(coord[2]) for coord in self.atoms]\n    z_curr_list = [float(coord[3]) for coord in self.atoms]\n    sur_lists = (x_curr_list, y_curr_list, z_curr_list)\n    # finding absorbent values\n    if absorbent_reference == \"Centroid\":\n        abs_mod = abs_centroids\n    elif absorbent_reference == \"Top\" or absorbent_reference == \"Bottom\":\n        abs_mod = abs_centroids\n        if absorbent_reference == \"Top\":\n            sort_func = max\n        else:  # if absorbent_reference == \"Bottom\":\n            sort_func = min\n        abs_mod[axis_int] = sort_func(abs_lists[axis_int])\n    else:\n        abs_mod = [0.0, 0.0, 0.0]\n    # finding surface values now\n    if isinstance(surface_reference, XYZCoord):\n        pass\n    elif isinstance(surface_reference, str):\n        pass\n    else:\n        raise ValueError(\"XYZMolecule.add_coords() required argument 'surface_reference' is not type str or XYZCoord.\") # yapf: disable\n    if isinstance(surface_reference, XYZCoord):\n        pass\n    elif surface_reference == \"Centroid\":\n        sur_mod = sur_centroids\n    elif surface_reference == \"(0.5,0.5,0.5)\":\n        sur_mod = [0.5, 0.5, 0.5]\n    elif surface_reference == \"Top\" or surface_reference == \"Bottom\":\n        if surface_reference == \"Top\":\n            sort_func = max\n        # if surface_reference == ABSORBENT_OPTIONS['starting_surface_list'][1]:\n        else:\n            sort_func = min\n        sur_mod[axis_int] = sort_func(sur_lists[axis_int])\n    elif \"Most positive \" in surface_reference or \"Most negative\" in surface_reference:\n        species = surface_reference[14:]\n        if \"Most positive \" in surface_reference:\n            sort_func = max\n        else:  # if \"Most negative\" in surface_reference:\n            sort_func = min\n        species_import_list = [float(coord[axis_int + 1])\n                               for coord in self.atoms if coord.sp == species]\n        sur_mod[axis_int] = sort_func(species_import_list)\n    else:  # necessary for add atom\n        sur_mod = [0, 0, 0]  # if surface_reference == 'origin'\n    # math for finding displacement distanceance\n    distance = [0.0, 0.0, 0.0]\n    distance[axis_int] = dist\n    x_mod = sur_mod[0] - abs_mod[0] + distance[0]\n    y_mod = sur_mod[1] - abs_mod[1] + distance[1]\n    z_mod = sur_mod[2] - abs_mod[2] + distance[2]\n    for ele in molecule.atoms:\n        combined_atoms.append(XYZCoord(ele.sp, float(\n            ele[1]) + x_mod, float(ele[2]) + y_mod, float(ele[3]) + z_mod))\n    if inplace:\n        self.atoms = combined_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=combined_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.append","title":"<code>append(new_coords, inplace=False)</code>","text":"<p>To add coords to the current self.atoms attribute.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.append--parameters","title":"Parameters","text":"<p>new_coords : XYZCoord or list[XYZCoord]     List of new coords to add to new object. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.append--returns","title":"Returns","text":"<p>XYZMolecule     description</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def append(self, new_coords: XYZCoord | list[XYZCoord], inplace: bool = False) -&gt; XYZMolecule:\n    \"\"\"To add coords to the current self.atoms attribute.\n\n    Parameters\n    ----------\n    new_coords : XYZCoord or list[XYZCoord]\n        List of new coords to add to new object.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    XYZMolecule\n        _description_\n    \"\"\"\n    if not isinstance(new_coords, list):\n        new_coords = [new_coords]\n    for n, item in enumerate(new_coords):\n        if not isinstance(item, XYZCoord):\n            raise ValueError(f\"XYZMolecule.__init__() index {n} of atoms is not type XYZCoord; item = {item}\") # yapf: disable\n    new_atoms = copy.copy(self.atoms)\n    new_atoms.extend(new_coords)\n    if inplace:\n        self.atoms = new_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=new_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.convert","title":"<code>convert(lattice_matrix, positional=True)</code>","text":"<p>Converts XYZMolecule instance to ABCMolecule.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.convert--parameters","title":"Parameters","text":"<p>lattice_matrix : LatticeMatrix     Instance of LatticeMatrix dataclass needed for ABCMolecule class. positional : bool, default True     If True, XYZ cartesian coordinates will convert to positional coordinates. If False, ABCMolecule will contain cartesian coordinates.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.convert--returns","title":"Returns","text":"<p>ABCMolecule     description</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def convert(self, lattice_matrix: LatticeMatrix, positional: bool = True) -&gt; ABCMolecule:\n    \"\"\"Converts XYZMolecule instance to ABCMolecule.\n\n    Parameters\n    ----------\n    lattice_matrix : LatticeMatrix\n        Instance of LatticeMatrix dataclass needed for ABCMolecule class.\n    positional : bool, default True\n        If True, XYZ cartesian coordinates will convert to positional coordinates. If False, ABCMolecule will contain cartesian coordinates.\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n    if positional:\n        alp, bet, gam = lattice_matrix.getanglesrad()\n        a, b, c = lattice_matrix.getabc()\n        A = [\n            [\n                csc(bet) / (a * np.sqrt(1 - (cot(alp) * cot(bet) - csc(alp) * csc(bet) * cos(gam)) ** 2)),\n                0,\n                0,\n            ],\n            [\n                ((csc(alp) ** 2) * csc(bet) * (cos(alp) * cos(bet) - cos(gam))) / (b * np.sqrt(1 - (cot(alp) * cot(bet) - csc(alp) * csc(bet) * cos(gam)) ** 2)),\n                csc(alp) / b,\n                0,\n            ],\n            [\n                (csc(alp) * ((cot(alp) * csc(bet) * cos(gam)) - (csc(alp) * cot(bet)))) / (c * np.sqrt(1 - (cot(alp) * cot(bet) - csc(alp) * csc(bet) * cos(gam)) ** 2)),\n                (-cot(alp)) / c,\n                1 / c,\n            ],\n        ]\n        convert_atoms: list[ABCCoord] = list()\n        for atom in self.atoms:\n            f = np.matrix([[atom.x], [atom.y], [atom.z]])\n            r = np.dot(A, f)\n            convert_atoms.append(\n                ABCCoord(atom.sp, float(r[0]), float(r[1]), float(r[2])))\n        return ABCMolecule(\n            comment_line=self.comment_line,\n            atoms=convert_atoms,\n            unitcell=lattice_matrix,\n            positional=positional,\n            filetype=self.filetype,\n        )\n    else:\n        return ABCMolecule(\n            comment_line=self.comment_line,\n            atoms=[ABCCoord(coord.sp, coord.x, coord.y, coord.z) for coord in self.atoms],\n            unitcell=lattice_matrix,\n            positional=positional,\n            filetype=self.filetype,\n        )\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.delete","title":"<code>delete(index, inplace=False)</code>","text":"<p>Delete INDEXED atoms in XYZMolecule.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.delete--parameters","title":"Parameters","text":"<p>index : MolIndex     description inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.delete--returns","title":"Returns","text":"<p>XYZMolecule or None     XYZMolecule with selected atoms deleted or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def delete(self, index: MolIndex, inplace: bool = False) -&gt; XYZMolecule:\n    \"\"\"Delete INDEXED atoms in XYZMolecule.\n\n    Parameters\n    ----------\n    index : MolIndex\n        _description_\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    XYZMolecule or None\n        XYZMolecule with selected atoms deleted or None if inplace=True.\n    \"\"\"\n    saving_atoms: list[XYZCoord] = list()\n    del_ints: list[int] = list()\n    if type(index) != list:\n        # not exactly sure why but good theres a small amount of type ignores for each molecule class\n        index = [index]  # type: ignore s\n    for item in index:  # type: ignore\n        for ele in self[item].atoms:\n            del_ints.append(self.atoms.index(ele))\n    saving_atoms = [self.atoms[i]\n                    for i in range(len(self.atoms)) if not i in del_ints]\n    if inplace:\n        self.atoms = saving_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=saving_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.format","title":"<code>format(endline=' ', filetype='.xyz')</code>","text":"<p>Returns formatted text for textbox or filewrite.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.format--parameters","title":"Parameters","text":"<p>endline : str, default \" \"     Endline string for each file line.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.format--returns","title":"Returns","text":"<p>list[str]     list of strings for xyz format with endline str as last character in string.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.format--notes","title":"Notes","text":"<p>Can replace text.append self.atoms with XYZCoord.line()</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def format(self, endline: str = \" \", filetype: str = \".xyz\") -&gt; list[str]:\n    \"\"\"Returns formatted text for textbox or filewrite.\n\n    Parameters\n    ----------\n    endline : str, default \" \"\n        Endline string for each file line.\n\n    Returns\n    -------\n    list[str]\n        list of strings for xyz format with endline str as last character in string.\n\n    Notes\n    -----\n    Can replace text.append self.atoms with XYZCoord.line()\n    \"\"\"\n    text: list[str] = list()\n    if filetype == \".xyz\":\n        text.append(f\"{self.total}\" + endline)\n        text.append(f\"{self.comment_line}\" + endline)\n        for i in range(len(self.atoms)):\n            text.append(f\"{self.atoms[i].sp:2}{self.atoms[i].x:&gt;{Lx}.{Fx}f}{self.atoms[i].y:&gt;{Lx}.{Fx}f}{self.atoms[i].z:&gt;{Lx}.{Fx}f}\" + endline)\n        return text\n    elif filetype == \".turbomole\":\n        text.append(\"$coord\" + endline)\n        for i in range(len(self.atoms)):\n            text.append(f\"{'': &lt;8}{self.atoms[i].x:&gt;{Lx}.{Fx}f}{self.atoms[i].y:&gt;{Lx}.{Fx}f}{self.atoms[i].z:&gt;{Lx}.{Fx}f}{'': &lt;4}{self.atoms[i].sp.lower():2}\" + endline)\n        text.append(\"$end\" + endline)\n        return text\n    else:\n        raise ValueError(\"XYZMolecule.format() optional argument 'filetype' is not '.xyz' or '.turbomole'\") # yapf: disable\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.get_centroid","title":"<code>get_centroid()</code>","text":"<p>Returns 3d centroid of XYZMolecule atoms.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.get_centroid--returns","title":"Returns","text":"<p>tuple[float,float,float]     Tuple of (x_centroid,y_centroid,z_centroid) in units Angstroms.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def get_centroid(self) -&gt; tuple[float, float, float]:\n    \"\"\"Returns 3d centroid of XYZMolecule atoms.\n\n    Returns\n    -------\n    tuple[float,float,float]\n        Tuple of (x_centroid,y_centroid,z_centroid) in units Angstroms.\n    \"\"\"\n    x_list = [coord.x for coord in self.atoms]\n    y_list = [coord.y for coord in self.atoms]\n    z_list = [coord.z for coord in self.atoms]\n    x_centroid = sum(x_list) / len(x_list)\n    y_centroid = sum(y_list) / len(y_list)\n    z_centroid = sum(z_list) / len(z_list)\n    return (x_centroid, y_centroid, z_centroid)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.info","title":"<code>info()</code>","text":"<p>Prints XYZMolecule current attribute information to terminal.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def info(self) -&gt; None:\n    \"\"\"Prints XYZMolecule current attribute information to terminal.\"\"\"\n    species_key = [x for i, x in enumerate(\n        self.species_line) if self.species_line.index(x) == i]\n    amount_dict = {sp: \"0\" for sp in species_key}\n    for ele, amt in zip(self.species_line, self.species_amount):\n        curr_value = amount_dict[ele]\n        new_value = int(amt) + int(curr_value)\n        amount_dict[ele] = str(new_value)\n    print(f\"type: XYZMolecule\\nfiletype: {self.filetype}\\ntotal atoms: {self.total}\\nspecies info: {amount_dict}\\ncomment line: '{self.comment_line}'\") # yapf: disable\n    return None\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.manipulate","title":"<code>manipulate(index, func, inplace=False, *args, **kwargs)</code>","text":"<p>Rotate or move only INDEXED atoms in XYZMolecule.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.manipulate--parameters","title":"Parameters","text":"<p>index : MolIndex     description func : \"{'move' or 'rotate'}\"     XYZMolecule method you want to execute on the indexed atoms. inplace : bool, default False     If True, perform operation in-place. args,*kwargs     Needed for the chosen function 'move' or 'rotate'.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.manipulate--returns","title":"Returns","text":"<p>XYZMolecule or None     XYZMolecule with all atoms moved or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def manipulate(self, index: MolIndex, func: str, inplace: bool = False, *args: Any, **kwargs: Any) -&gt; XYZMolecule:\n    \"\"\"Rotate or move only INDEXED atoms in XYZMolecule.\n\n    Parameters\n    ----------\n    index : MolIndex\n        _description_\n    func : \"{'move' or 'rotate'}\"\n        XYZMolecule method you want to execute on the indexed atoms.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    *args,**kwargs\n        Needed for the chosen function 'move' or 'rotate'.\n\n    Returns\n    -------\n    XYZMolecule or None\n        XYZMolecule with all atoms moved or None if inplace=True.\n    \"\"\"\n    i_list: list[int] = list()\n    moving_atoms: list[XYZCoord] = list()\n    if type(index) != list:\n        index = [index]  # type: ignore\n    for item in index:  # type: ignore\n        for ele in self[item].atoms:\n            i_list.append(self.atoms.index(ele))\n            moving_atoms.append(ele)\n    moving_mol = XYZMolecule(atoms=moving_atoms)\n    if func == \"move\":\n        new_mol = moving_mol.move(*args, **kwargs)\n    elif func == \"rotate\":\n        new_mol = moving_mol.rotate(*args, **kwargs)\n    else:\n        raise ValueError(\"XYZMolecule.manipulate() required argument 'func' not 'move' or 'rotate'\") # yapf: disable\n    new_atoms = self.atoms\n    for n, ele in zip(i_list, new_mol.atoms):\n        new_atoms[n] = ele\n    if inplace:\n        self.atoms = new_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=new_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.move","title":"<code>move(x=0, y=0, z=0, inplace=False)</code>","text":"<p>Move ALL atoms in designated directions.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.move--parameters","title":"Parameters","text":"<p>x : float, default 0.0     Move coord in x direction by float amount. y : float, default 0.0     Move coord in y direction by float amount. z : float, default 0.0     Move coord in z direction by float amount. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.move--returns","title":"Returns","text":"<p>XYZMolecule or None     XYZMolecule with all atoms moved or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def move(self, x: float = 0, y: float = 0, z: float = 0, inplace: bool = False) -&gt; XYZMolecule:\n    \"\"\"Move ALL atoms in designated directions.\n\n    Parameters\n    ----------\n    x : float, default 0.0\n        Move coord in x direction by float amount.\n    y : float, default 0.0\n        Move coord in y direction by float amount.\n    z : float, default 0.0\n        Move coord in z direction by float amount.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    XYZMolecule or None\n        XYZMolecule with all atoms moved or None if inplace=True.\n    \"\"\"\n    if type(x) not in [int, float]:\n        raise ValueError(f\"XYZMolecule.move() optional argument 'x' is not a number\") # yapf: disable\n    if type(y) not in [int, float]:\n        raise ValueError(f\"XYZMolecule.move() optional argument 'y' is not a number\") # yapf: disable\n    if type(z) not in [int, float]:\n        raise ValueError(f\"XYZMolecule.move() optional argument 'z' is not a number\") # yapf: disable\n    if not isinstance(inplace, bool):\n        raise ValueError(\"XYZMolecule.move() optional argument 'inplace' is not a bool\") # yapf: disable\n    return_atoms: list[XYZCoord] = list()\n    for coord in self.atoms:\n        sp = coord.sp\n        x_old = coord.x\n        y_old = coord.y\n        z_old = coord.z\n        return_atoms.append(\n            XYZCoord(sp=sp, x=x_old + x, y=y_old + y, z=z_old + z))\n    if inplace:\n        self.atoms = return_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.printt","title":"<code>printt()</code>","text":"<p>Prints save file text to terminal.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def printt(self) -&gt; None:\n    \"\"\"Prints save file text to terminal.\"\"\"\n    for line in self.format(endline=\" \"):\n        print(line)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.rotate","title":"<code>rotate(axis, angle, unit='deg', about_centroid=True, inplace=False)</code>","text":"<p>Rotate ALL atoms about designated axis.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.rotate--parameters","title":"Parameters","text":"<p>axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"     Parallel axis of rotation. angle : float     Angle of rotation. unit : \"deg\" or \"rad\", default \"deg\"     Unit of angle argument. about_centroid : bool, default True     If True, rotation occurs about the centroid. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.rotate--returns","title":"Returns","text":"<p>XYZMolecule or None     XYZMolecule with all atoms moved or None if inplace=True.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def rotate(\n    self,\n    axis: str,\n    angle: float,\n    unit: str = \"deg\",\n    about_centroid: bool = True,\n    inplace: bool = False,\n) -&gt; XYZMolecule:\n    \"\"\"Rotate ALL atoms about designated axis.\n\n    Parameters\n    ----------\n    axis : \"{0 or 'x', 1 or 'y', 2 or 'z'}\"\n        Parallel axis of rotation.\n    angle : float\n        Angle of rotation.\n    unit : \"deg\" or \"rad\", default \"deg\"\n        Unit of angle argument.\n    about_centroid : bool, default True\n        If True, rotation occurs about the centroid.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    XYZMolecule or None\n        XYZMolecule with all atoms moved or None if inplace=True.\n    \"\"\"\n    if axis not in [\"x\", \"y\", \"z\"]:\n        raise ValueError(f\"XYZMolecule.move() required argument 'angle' is not 'x' or 'y' or 'z' \") # yapf: disable\n    if type(angle) not in [int, float]:\n        raise ValueError(f\"XYZMolecule.rotate() required argument 'angle' is not a number\") # yapf: disable\n    if unit not in [\"deg\", \"rad\"]:\n        raise ValueError(f\"XYZMolecule.rotate() required argument 'unit' is not 'deg' or 'rad'\") # yapf: disable\n    if not isinstance(inplace, bool):\n        raise ValueError(\"XYZMolecule.rotate() optional argument 'inplace' is not a bool\") # yapf: disable\n    if unit == \"deg\":\n        angle *= pi / 180\n    match axis:\n        case \"x\":\n\n            def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n                return x, y * cos(angle) - z * sin(angle), y * sin(angle) + z * cos(angle)\n\n        case \"y\":\n\n            def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n                return x * cos(angle) + z * sin(angle), y, z * cos(angle) - x * sin(angle)\n\n        case \"z\":\n\n            def rotation(x: float, y: float, z: float) -&gt; tuple[float, float, float]:\n                return x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle), z\n\n        case _:\n\n            raise Exception(\"XYZMolecule.rotate() required argument 'axis' is not 'x','y', or 'z'\") # yapf: disable\n\n    return_atoms: list[XYZCoord] = list()\n    if about_centroid:\n        x_cent, y_cent, z_cent = self.get_centroid()\n    else:\n        x_cent = y_cent = z_cent = 0.0\n    for coord in self.atoms:\n        rot_x, rot_y, rot_z = rotation(float(coord.x) - x_cent, float(coord.y) - y_cent, float(coord.z) - z_cent)\n        return_atoms.append(XYZCoord(sp=coord.sp, x=rot_x + x_cent, y=rot_y + y_cent, z=rot_z + z_cent))\n    if inplace:\n        self.atoms = return_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.save","title":"<code>save(filename, filetype='.xyz')</code>","text":"<p>Save XYZMolecule instance to given filename in current working directory.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.save--parameters","title":"Parameters","text":"<p>filename : str     Name you want the saved file to be.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.save--returns","title":"Returns","text":"<p>filename.xyz in current working directory.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def save(self, filename: str, filetype: str = \".xyz\") -&gt; None:\n    \"\"\"Save XYZMolecule instance to given filename in current working directory.\n\n    Parameters\n    ----------\n    filename : str\n        Name you want the saved file to be.\n\n    Returns\n    -------\n    filename.xyz in current working directory.\n    \"\"\"\n    if filetype not in [\".xyz\",\".turbomole\"]:\n        raise ValueError(\"XYZMolecule.save() optional argument 'filetype' is not '.xyz' or '.turbomole'\") # yapf: disable\n    with open(os.path.join(os.getcwd(), filename), \"w\") as openfile:\n        for line in self.format(endline=\"\\n\", filetype=filetype):\n            openfile.writelines(line)\n</code></pre>"},{"location":"reference/#molecule_lib.XYZMolecule.sort","title":"<code>sort(sort_method, ascending=True, inplace=False)</code>","text":"<p>Sort the atoms in Molecule instance by position, species, alphabetical or atomic number.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.sort--parameters","title":"Parameters","text":"<p>sort_method : str | list[str] | list[list[str]]     Method given by which the atoms will be sorted.         - if sort_method is 'x' the atoms will be sorted by their x coordinate.         - if sort_method is 'y' the atoms will be sorted by their y coordinate.         - if sort_method is 'z' the atoms will be sorted by their z coordinate.         - if sort_method is 'alphabetical' the atoms will be sorted in alphabetical order by their species.         - if sort_method is 'periodical' the atoms will be sorted by their atomic number.     You can also supply a list of lists with position 0 being species and position 1 being 'x','y','z', or None.         This will sort the coordinates by species then by the method provided for each species,         you can also add a list of bool for ascending values that will correspond to each species chosen method.     You can also supply a list of species and it will be reordered to the given order. ascending : bool or list of bool, default True     Sort ascending vs. descending. Specify list for multiple sort orders (as described above). If this is a list of bools, must match the length of sort_method. inplace : bool, default False     If True, perform operation in-place.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.sort--returns","title":"Returns","text":"<p>XYZMolecule or None     XYZMolecule with all atoms moved or None if inplace=True.</p>"},{"location":"reference/#molecule_lib.XYZMolecule.sort--notes","title":"Notes","text":"<p>sort method +x,-x,+y,-y,+z,-z,species,sp list,alphabetical,periodical,</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def sort(\n    self,\n    sort_method: str | list[str] | list[list[str]],\n    ascending: bool | list[bool] = True,\n    inplace: bool = False,\n) -&gt; XYZMolecule | None:\n    \"\"\"Sort the atoms in Molecule instance by position, species, alphabetical or atomic number.\n\n    Parameters\n    ----------\n    sort_method : str | list[str] | list[list[str]]\n        Method given by which the atoms will be sorted.\n            - if sort_method is 'x' the atoms will be sorted by their x coordinate.\n            - if sort_method is 'y' the atoms will be sorted by their y coordinate.\n            - if sort_method is 'z' the atoms will be sorted by their z coordinate.\n            - if sort_method is 'alphabetical' the atoms will be sorted in alphabetical order by their species.\n            - if sort_method is 'periodical' the atoms will be sorted by their atomic number.\n        You can also supply a list of lists with position 0 being species and position 1 being 'x','y','z', or None.\n            This will sort the coordinates by species then by the method provided for each species,\n            you can also add a list of bool for ascending values that will correspond to each species chosen method.\n        You can also supply a list of species and it will be reordered to the given order.\n    ascending : bool or list of bool, default True\n        Sort ascending vs. descending. Specify list for multiple sort orders (as described above). If this is a list of bools, must match the length of sort_method.\n    inplace : bool, default False\n        If True, perform operation in-place.\n\n    Returns\n    -------\n    XYZMolecule or None\n        XYZMolecule with all atoms moved or None if inplace=True.\n\n    Notes\n    -----\n    sort method +x,-x,+y,-y,+z,-z,species,sp list,alphabetical,periodical,\n    \"\"\"\n    if isinstance(sort_method, str):\n        if sort_method not in [\"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\", None]:\n            raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' is not one of 'x','y','z','alphabetical','periodical'\") # yapf: disable\n        # making individual string so it can work in for loop enumerate below\n        sort_method = [sort_method]\n    elif isinstance(sort_method, list) or isinstance(sort_method, tuple):\n        if len(sort_method) != len(self.species_line):\n            raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' not the same length of amount of species in XYZMolecule\") # yapf: disable\n        for item in sort_method:\n            if isinstance(item, str):\n                item = [item]\n            if not isinstance(item, list) and not isinstance(item, tuple):\n                raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item not correct type\") # yapf: disable\n            if len(item) == 1:\n                if item[0] not in self.species_line:\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line (len(item)=1)\") # yapf: disable\n            elif len(item) == 2:\n                if item[0] not in self.species_line:\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item position 0 not species in self.species_line\") # yapf: disable\n                if item[1] not in [\"x\", \"y\", \"z\", \"None\", None]:\n                    raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item position 1 is not one of type 'x','y','z','None',None (len(item)=2)\") # yapf: disable\n            else:\n                raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list item length &gt; 2\") # yapf: disable\n    else:\n        raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' not correct types\") # yapf: disable\n    if isinstance(ascending, list) or isinstance(ascending, tuple):\n        if not isinstance(sort_method, list) and not isinstance(sort_method, tuple):\n            raise ValueError(\"XYZMolecule.sort() ascending is type list but sortmethod is not type list\") # yapf: disable\n        if len(sort_method) != len(ascending):\n            raise ValueError(\"XYZMolecule.sort() length of ascending list not equivalent to length of sort method\") # yapf: disable\n        if not all([isinstance(item, bool) for item in ascending]):\n            raise ValueError(\"XYZMolecule.sort() ascending list[bool] not all bool type\") # yapf: disable\n    elif not isinstance(ascending, bool):\n        raise ValueError(\"XYZMolecule.sort() ascending bool type not bool type\") # yapf: disable\n    return_atoms: list[XYZCoord] = list()\n    for n, item in enumerate(sort_method):\n        if isinstance(ascending, bool):\n            reverse_bool = False if ascending else True\n        elif isinstance(ascending, list) and len(ascending) == 1:\n            reverse_bool = False if ascending[0] else True\n        elif len(ascending) == len(sort_method):\n            reverse_bool = False if ascending[n] else True\n        else:\n            raise ValueError(\"XYZMolecule.sort() ascending argument is wrong\") # yapf: disable\n        if isinstance(item, list) or isinstance(item, tuple):\n            if len(item) == 1:\n                tobesorted = self.atoms  # for string\n                method = item[0]\n            elif item[0] in self.species_line:\n                tobesorted = self[item[0]].atoms\n                method = item[1]\n            else:\n                raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' is not correct\") # yapf: disable\n        else: #if isinstance(item, str):\n            if item in self.species_line:\n                tobesorted = self[item].atoms\n                method = \"None\"\n            elif item in [\"x\", \"y\", \"z\", \"alphabetical\", \"periodical\", \"None\", None]:\n                # raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list species index 1 is not one of 'x','y','z','alphabetical','periodical','None',None\") # yapf: disable\n                method = item\n                tobesorted = self.atoms\n            else:\n                raise ValueError(\"XYZMolecule.sort() required argument 'sort_method' list species does not contain species\") # yapf: disable\n        if method == \"x\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x[1], reverse=reverse_bool))\n        elif method == \"y\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x[2], reverse=reverse_bool))\n        elif method == \"z\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x[3], reverse=reverse_bool))\n        elif method == \"alphabetical\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: x.sp, reverse=reverse_bool))\n        elif method == \"periodical\":\n            return_atoms.extend(sorted(tobesorted, key=lambda x: ACCEPTED_ELEMENTS.index(x.sp), reverse=reverse_bool))\n        else:\n            return_atoms.extend(tobesorted)\n    if inplace:\n        self.atoms = return_atoms\n        self.__post_init__()\n    return XYZMolecule(atoms=return_atoms, comment_line=self.comment_line, filetype=self.filetype,)\n</code></pre>"},{"location":"reference/#xyz-functions","title":"XYZ Functions","text":""},{"location":"reference/#molecule_lib.isturbomolelist","title":"<code>molecule_lib.isturbomolelist(data_list)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>data_list</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> <li> <code>extralines</code>             (<code>bool</code>)         \u2013          <p>description, by default False</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def isturbomolelist(data_list: list[list[str]]) -&gt; bool:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    data_list : list[list[str]]\n        _description_\n    extralines : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    bool\n        _description_\n    \"\"\"\n    ACCEPTED_ELEMENTS_lower_case = [ele.lower() for ele in ACCEPTED_ELEMENTS]\n    if data_list[0] == [] or len(data_list[0]) != 1:\n        print(\"1\")\n        return False\n    if data_list[0][0] != \"$coord\":\n        print(\"2\")\n        return False\n    if [\"$user-defined bonds\"] in data_list:\n        final_atom_index = data_list.index([\"$user-defined bonds\"])\n    elif [\"$end\"] in data_list:\n        final_atom_index = data_list.index([\"$end\"])\n    else:\n        print(\"3\")\n        return False\n    for line in data_list[1:final_atom_index-1]:\n        if len(line) &lt; 4:\n            print(\"4\")\n            return False\n        if ( _isfloatstr(line[0]) is False or _isfloatstr(line[1]) is False\n        and _isfloatstr(line[2]) is False or line[3] not in ACCEPTED_ELEMENTS_lower_case):\n            print(\"5\")\n            return False\n    return True\n</code></pre>"},{"location":"reference/#molecule_lib.create_from_turbomole_file_data","title":"<code>molecule_lib.create_from_turbomole_file_data(file_data)</code>","text":"Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def create_from_turbomole_file_data(file_data: list[list[str]]) -&gt; XYZMolecule:\n    if not isturbomolelist(data_list=file_data):\n        raise Exception(\"parsererror, not turbomolelist\")\n    atoms: list[XYZCoord] = list()\n    if [\"$user-defined bonds\"] in file_data:\n        final_atom_index = file_data.index([\"$user-defined bonds\"])\n    else: #if [\"$end\"] in file_data:\n        final_atom_index = file_data.index([\"$end\"])\n    for line in file_data[1:final_atom_index-1]:\n        atoms.append(XYZCoord(sp=line[3].capitalize(),x=float(line[0]),y=float(line[1]),z=float(line[2])))\n    return XYZMolecule(atoms=atoms,filetype=\".turbomole\")\n</code></pre>"},{"location":"reference/#molecule_lib.read_turbomole","title":"<code>molecule_lib.read_turbomole(filepath)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>XYZMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def read_turbomole(filepath: str) -&gt; XYZMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    filepath : str\n        _description_\n\n    Returns\n    -------\n    XYZMolecule\n        _description_\n    \"\"\"\n    if type(filepath) != str:\n        raise Exception(\"Filepath not a string\")\n    if os.path.isfile(filepath) is False:\n        raise Exception(\"Filepath does not exist\")\n    with open(filepath, \"r\") as openfile:\n        file_data = [line.split() for line in openfile]\n    return create_from_turbomole_file_data(file_data=file_data)\n</code></pre>"},{"location":"reference/#molecule_lib.isxyzlist","title":"<code>molecule_lib.isxyzlist(data_list, extralines=False)</code>","text":"<p>Return True if datalist fufills .xyz file standards, False otherwise.</p> <p>Parameters:</p> <ul> <li> <code>data_list</code>             (<code>(list of filelines.split())</code>)         \u2013          <p>Is a list of list of filelines where each string in the file line seperated by a space is its own element in the list. data_list[0] is the contains the first line information of the file and data_list[-1] contains the last line 0 information of the file.</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, if there are extra lines in the file, function returns False. It is quote 'strict' on extra lines if True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if .xyz file standards are met.</p> </li> </ul> Notes <p>.xyz file standards:     - first line contains a integer (total amount of atoms in file).     - third line to last line of file contains only this information,         'Element   float(x coord)   float(y coord)   float(z coord)'.     - if total amount of atoms in the file matches the amount of data lines         found in the file.     - if there are no empty or blank lines at the end of the file.     - it is STRICT if extralines if True on the amount of empty line at the end of the file.</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def isxyzlist(data_list: list[list[str]], extralines: bool = False) -&gt; bool:\n    \"\"\"Return True if datalist fufills .xyz file standards, False otherwise.\n\n    Parameters\n    ----------\n    data_list : (list of filelines.split())\n        Is a list of list of filelines\n        where each string in the file line seperated by a space is its own\n        element in the list. data_list[0] is the contains the first line\n        information of the file and data_list[-1] contains the last line\n        0 information of the file.\n    extralines: bool, default True\n        If True, if there are extra lines in the file, function returns False.\n        It is quote 'strict' on extra lines if True.\n\n    Returns\n    -------\n    bool\n        True if .xyz file standards are met.\n\n    Notes\n    -----\n    .xyz file standards:\n        - first line contains a integer (total amount of atoms in file).\n        - third line to last line of file contains only this information,\n            'Element   float(x coord)   float(y coord)   float(z coord)'.\n        - if total amount of atoms in the file matches the amount of data lines\n            found in the file.\n        - if there are no empty or blank lines at the end of the file.\n        - it is STRICT if extralines if True on the amount of empty line at the end of the file.\n    \"\"\"\n    if data_list[0] == [] or len(data_list[0]) != 1:\n        return False\n    if data_list[0][0].isdecimal() is False:\n        return False\n    if data_list[1] == []:\n        try:\n            data_list[1][0] = \"\"\n        except:\n            data_list[1].extend(\"\")\n    if len(data_list) &lt; int(data_list[0][0]) + 2:\n        return False\n    for i in range(2, int(data_list[0][0])):\n        if (\n            len(data_list[i]) &lt; 4\n            or data_list[i][0] not in ACCEPTED_ELEMENTS\n            or _isfloatstr(data_list[i][1]) is False\n            or _isfloatstr(data_list[i][2]) is False\n            or _isfloatstr(data_list[i][3]) is False\n        ):\n            return False\n    if extralines:\n        data_list = [i for i in data_list if i != []]\n    if len(data_list) != int(data_list[0][0]) + 2:\n        return False\n    return True\n</code></pre>"},{"location":"reference/#molecule_lib.create_from_xyz_file_data","title":"<code>molecule_lib.create_from_xyz_file_data(file_data, extralines=False)</code>","text":"Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def create_from_xyz_file_data(file_data: list[list[str]], extralines: bool = False) -&gt; XYZMolecule:\n    if not isxyzlist(data_list=file_data, extralines=extralines):\n        raise Exception(\"parsererror, not xyzlist\")\n    return XYZMolecule(\n        comment_line=\" \".join(file_data[1]),\n        atoms=[\n            XYZCoord(\n                file_data[i][0],\n                float(file_data[i][1]),\n                float(file_data[i][2]),\n                float(file_data[i][3])\n            )\n            for i in range(2, int(file_data[0][0]) + 2)\n        ],\n        filetype=\".xyz\"\n    )\n</code></pre>"},{"location":"reference/#molecule_lib.read_xyz","title":"<code>molecule_lib.read_xyz(filepath, extralines=False)</code>","text":"<p>Reads .xyz file and returns XYZMolecule instance.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>Filename (if in current working directory) or absolute path or os.path.join(os.getcwd(),'filename.xyz')</p> </li> <li> <code>extralines</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, if there are extra lines in the file, function will not return XYZMolecule instance. It is quote 'strict' on extra lines if True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>XYZMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def read_xyz(filepath: str, extralines: bool = False) -&gt; XYZMolecule:\n    \"\"\"Reads .xyz file and returns XYZMolecule instance.\n\n    Parameters\n    ----------\n    filepath : str\n        Filename (if in current working directory)\n        or absolute path or os.path.join(os.getcwd(),'filename.xyz')\n    extralines: bool, default True\n        If True, if there are extra lines in the file, function will not return XYZMolecule instance.\n        It is quote 'strict' on extra lines if True.\n\n    Returns\n    -------\n    XYZMolecule\n        _description_\n    \"\"\"\n    if type(filepath) != str:\n        raise Exception(\"Filepath not a string\")\n    if os.path.isfile(filepath) is False:\n        raise Exception(\"Filepath does not exist\")\n    with open(filepath, \"r\") as openfile:\n        file_data = [line.split() for line in openfile]\n    return create_from_xyz_file_data(file_data=file_data, extralines=extralines)\n</code></pre>"},{"location":"reference/#more-file-reading-formats","title":"More File Reading Formats","text":""},{"location":"reference/#molecule_lib._is_xsf_coord_line","title":"<code>molecule_lib._is_xsf_coord_line(line)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>line</code>             (<code>list[str]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def _is_xsf_coord_line(line:list[str]) -&gt; bool:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    line : list[str]\n        _description_\n\n    Returns\n    -------\n    bool\n        _description_\n    \"\"\"\n    if line == []:\n        return False\n    if len(line) == 0:\n        return False\n    if not line[0].isdecimal():\n        return False\n    if 1 &gt; int(line[0]) and int(line[0]) &gt; 118:\n        return False\n    if len(line) &lt; 4:\n        return False\n    if not _isfloatstr(line[1]) or not _isfloatstr(line[2]) or not _isfloatstr(line[3]):\n        return False\n    return True\n</code></pre>"},{"location":"reference/#molecule_lib._determine_rest_of_xsf_file","title":"<code>molecule_lib._determine_rest_of_xsf_file(rest_of_file)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>rest_of_file</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[bool, int]</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def _determine_rest_of_xsf_file(rest_of_file: list[list[str]]) -&gt; tuple[bool, int]:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    rest_of_file : list[list[str]]\n        _description_\n\n    Returns\n    -------\n    tuple[bool, int]\n        _description_\n    \"\"\"\n    n = 0\n    for line in rest_of_file:\n        if _is_xsf_coord_line(line) is False:\n            break\n        n += 1\n    for line in rest_of_file[n+1:]:\n        if _is_xsf_coord_line(line):\n            return (False, 0)\n    return (True, n)\n</code></pre>"},{"location":"reference/#molecule_lib.isxsflist","title":"<code>molecule_lib.isxsflist(data_list)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>data_list</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def isxsflist(data_list: list[list[str]]) -&gt; bool:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    data_list : list[list[str]]\n        _description_\n\n    Returns\n    -------\n    bool\n        _description_\n    \"\"\"\n    if [\"PRIMVEC\"] in data_list and [\"PRIMCOORD\"] in data_list:\n        if not _is3byxfloatmatrix(data_list[data_list.index([\"PRIMVEC\"])+1:data_list.index([\"PRIMVEC\"])+3]):\n            return False\n        if not data_list[data_list.index([\"PRIMCOORD\"])+1][0].isdecimal() or data_list[data_list.index([\"PRIMCOORD\"])+1][1] != \"1\":\n            return False\n        if not _determine_rest_of_xsf_file(rest_of_file=data_list[data_list.index([\"PRIMCOORD\"])+2:])[0]:\n            return False\n        if int(data_list[data_list.index([\"PRIMCOORD\"])+1][0]) == _determine_rest_of_xsf_file(rest_of_file=data_list[data_list.index([\"PRIMCOORD\"])+2:])[1]:\n            return True\n        return False\n    elif [\"ATOMS\"] in data_list:\n        if not _determine_rest_of_xsf_file(rest_of_file=data_list[data_list.index([\"ATOMS\"])+1:])[0]:\n            return False\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/#molecule_lib.create_from_xsf_file_data","title":"<code>molecule_lib.create_from_xsf_file_data(file_data)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>file_data</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule | XYZMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def create_from_xsf_file_data(file_data: list[list[str]]) -&gt; ABCMolecule | XYZMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    file_data : list[list[str]]\n        _description_\n\n    Returns\n    -------\n    ABCMolecule | XYZMolecule\n        _description_\n    \"\"\"\n    if not isxsflist(data_list=file_data):\n        raise Exception(\"parsererror, not xsflist\")\n    if [\"CONVVEC\"] in file_data:\n        # pass #abc format\n        print(\"read_xsf(): DEPRECATION WARNING: Not currently supported to save CONVVEC Information\") # yapf: disable\n    if [\"ATOMS\"] in file_data:\n        xyz_atoms: list[XYZCoord] = list()\n        tot = _determine_rest_of_xsf_file(rest_of_file=file_data[file_data.index([\"ATOMS\"])+1:])[1]\n        for line in file_data[file_data.index([\"ATOMS\"])+1:file_data.index([\"ATOMS\"])+tot]:\n            xyz_atoms.append(XYZCoord(sp=ACCEPTED_ELEMENTS[int(line[0])],x=float(line[1]),y=float(line[2]),z=float(line[3])))\n        return XYZMolecule(atoms=xyz_atoms, comment_line=\"from .xsf format\",filetype=\".xsf\")\n    else:\n        abc_atoms: list[ABCCoord] = list()\n        tot = int(file_data[file_data.index([\"PRIMCOORD\"])+1][0])\n        for line in file_data[file_data.index([\"PRIMCOORD\"])+2:file_data.index([\"PRIMCOORD\"])+2+tot]:\n            abc_atoms.append(ABCCoord(sp=ACCEPTED_ELEMENTS[int(line[0])],a=float(line[1]),b=float(line[2]),c=float(line[3])))\n        uc_ind = file_data.index([\"PRIMVEC\"])\n        unitcell = LatticeMatrix(constant=1,\n                                 vector_1=[float(file_data[uc_ind+1][0]),float(file_data[uc_ind+1][1]),float(file_data[uc_ind+1][2])],\n                                 vector_2=[float(file_data[uc_ind+2][0]),float(file_data[uc_ind+2][1]),float(file_data[uc_ind+2][2])],\n                                 vector_3=[float(file_data[uc_ind+3][0]),float(file_data[uc_ind+3][1]),float(file_data[uc_ind+3][2])])\n        return ABCMolecule(unitcell=unitcell,positional=False,atoms=abc_atoms,comment_line=\"from xsf file\",filetype=\".xsf\",)\n</code></pre>"},{"location":"reference/#molecule_lib.read_xsf","title":"<code>molecule_lib.read_xsf(filepath)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule | XYZMolecule</code>         \u2013          <p>description</p> </li> </ul> Notes <p>Need to ensure keywords for xyzmolecule is only ATOMS and keyword for abcmolecule is \"primvec\" and \"primcoord\"</p> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def read_xsf(filepath: str) -&gt; ABCMolecule | XYZMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    filepath : str\n        _description_\n\n    Returns\n    -------\n    ABCMolecule | XYZMolecule\n        _description_\n\n    Notes\n    -----\n    Need to ensure keywords for xyzmolecule is only ATOMS\n    and keyword for abcmolecule is \"primvec\" and \"primcoord\"\n    \"\"\"\n    if type(filepath) != str:\n        raise Exception(\"Filepath not a string\")\n    if os.path.isfile(filepath) is False:\n        raise Exception(\"Filepath does not exist\")\n    with open(filepath, \"r\") as openfile:\n        file_data = [line.split() for line in openfile]\n    return create_from_xsf_file_data(file_data=file_data)\n</code></pre>"},{"location":"reference/#molecule_lib.issiestalist","title":"<code>molecule_lib.issiestalist(data_list)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>data_list</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def issiestalist(data_list: list[list[str]]) -&gt; bool:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    data_list : list[list[str]]\n        _description_\n\n    Returns\n    -------\n    bool\n        _description_\n    \"\"\"\n    for line in data_list:\n        if \"LatticeConstant\" in line:\n            if not _isfloatstr(line[1]):\n                return False\n            if ['%block', 'LatticeVectors'] in data_list and ['%endblock', 'LatticeVectors'] in data_list:\n                print(data_list[data_list.index(['%block', 'LatticeVectors'])+1:data_list.index(['%endblock', 'LatticeVectors'])]) # yapf: disable\n                if not _is3byxfloatmatrix(data_list[data_list.index(['%block', 'LatticeVectors'])+1:data_list.index(['%endblock', 'LatticeVectors'])]):\n                    return False\n                break\n            else:\n                return False\n    if ['%block', 'AtomicCoordinatesAndAtomicSpecies'] not in data_list or ['%endblock', 'AtomicCoordinatesAndAtomicSpecies'] not in data_list:\n        return False\n    for line in data_list[data_list.index(['%block', 'AtomicCoordinatesAndAtomicSpecies'])+1:data_list.index(['%endblock', 'AtomicCoordinatesAndAtomicSpecies'])]:\n        if len(line) &lt; 4:\n            return False\n        if not _isfloatstr(line[0]) or not _isfloatstr(line[1]) or not _isfloatstr(line[2]):\n            return False\n        if not line[3].isdecimal():\n            return False\n    return True\n</code></pre>"},{"location":"reference/#molecule_lib.create_from_siesta_file_data","title":"<code>molecule_lib.create_from_siesta_file_data(file_data)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>file_data</code>             (<code>list[list[str]]</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def create_from_siesta_file_data(file_data: list[list[str]]) -&gt; ABCMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    file_data : list[list[str]]\n        _description_\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n    if not issiestalist(data_list=file_data):\n        raise Exception(\"parsererror, not siestalist\")\n    for line in file_data:\n        if \"LatticeConstant\" in line:\n            constant = float(line[1])\n    lattice = file_data[file_data.index(['%block', 'LatticeVectors'])+1:file_data.index(['%endblock', 'LatticeVectors'])]\n    unitcell = LatticeMatrix(\n        constant=constant,\n        vector_1=[float(lattice[0][0]),float(lattice[0][1]),float(lattice[0][2])],\n        vector_2=[float(lattice[1][0]),float(lattice[1][1]),float(lattice[1][2])],\n        vector_3=[float(lattice[2][0]),float(lattice[2][1]),float(lattice[2][2])])\n    abc_atoms: list[ABCCoord] = list()\n    for line in file_data[file_data.index(['%block', 'AtomicCoordinatesAndAtomicSpecies'])+1:file_data.index(['%endblock', 'AtomicCoordinatesAndAtomicSpecies'])]:\n        abc_atoms.append(ABCCoord(sp=ACCEPTED_ELEMENTS[int(line[3])],a=float(line[0]),b=float(line[1]),c=float(line[2])))\n    return ABCMolecule(unitcell=unitcell, positional=True, atoms=abc_atoms,comment_line=\"from siesta input deck\",filetype=\".fdf\",)\n</code></pre>"},{"location":"reference/#molecule_lib.read_siesta","title":"<code>molecule_lib.read_siesta(filepath)</code>","text":"<p>summary</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>             (<code>str</code>)         \u2013          <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ABCMolecule</code>         \u2013          <p>description</p> </li> </ul> Source code in <code>molecule_lib\\__init__.py</code> <pre><code>def read_siesta(filepath: str) -&gt; ABCMolecule:\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    filepath : str\n        _description_\n\n    Returns\n    -------\n    ABCMolecule\n        _description_\n    \"\"\"\n    if type(filepath) != str:\n        raise Exception(\"Filepath not a string\")\n    if os.path.isfile(filepath) is False:\n        raise Exception(\"Filepath does not exist\")\n    with open(filepath, \"r\") as openfile:\n        file_data = [line.split() for line in openfile]\n    return create_from_siesta_file_data(file_data=file_data)\n</code></pre>"},{"location":"todo/","title":"What is planned to be added to it in the future (aka TODO list)","text":"<ol> <li>Add support for lammps, and .cif</li> <li>Add generate supercell method</li> <li>Maybe change inplace ideology</li> <li>Change logic for read functions so no extralines argument. It will be flexible on extra lines at the end of the file.</li> <li>Add documentation for everything and maybe an examples page and an intro page</li> <li>Maybe change how add_coord function works.</li> </ol>"},{"location":"todo/#notes-from-word-document","title":"Notes from word document","text":"<p>Shift alt o for formatting import statements Ideas for structmake</p>"},{"location":"todo/#pip-install-xtb","title":"Pip install xtb","text":""},{"location":"todo/#run-xtb-locally-first","title":"Run xtb locally first","text":"<p>Then run crest on hpcc using submission script \u2022   Still two main molecule objects (abcmolecule and xyzmolecule) but there will be a specified initial file type \u2022   DONE(not using dataclasses anymore lol) Might need to not use dataclasses in order to stop the linking objects that occurs For coord objects \u2022   Add a .get() method for coord data classes that returns (x,y,z) For read_filetypes() \u2022   Raise ParserError when something goes wrong \u2022   Setting extralines: bool = False, strict on extra lines at EOF \u2022   Index = -1 , default \u2022   Different filetypes im looking at o   .xyz  o   .vasp/POSCAR o   .xyz animation o   .vasp animation/XDATCAR o   .cif o   .xsf o   .fdf o   Others: .json, .sdf not really sure if there is a common format For Molecule objects \u2022   get_item(self) :If you index the molecule object [] it returns a new object with the atoms you selected. Based loosely on pandas indexing o   Index types, first index is 1 (not python convention but makes sense in use case) \uf0a7   Done \uf0a7   Int \u2013 indexing is 1 \uf0a7   \u2018Al\u2019 \u2013 all singular species type \uf0a7   \u2018Al1\u2019 \u2013 VESTA naming  \uf0a7   \u20181\u2019 - int \uf0a7   List of int [1,3,4,5,8,9,10,11] \uf0a7   List of str \u2022   [\u2018Al\u2019,\u2019F\u2019] \u2013 all species type \u2022   [\u20181\u2019,\u20192\u2019,\u20193\u2019] atom_number (covers molden numbering style without the species in it) \u2022   [\u2018Al1\u2019,\u2019O3\u2019] vesta numbering style \uf0a7   Not implemented yet \u2022   Range of int [1:20] \u2022   Add method similar to .format() but  Do .to_xyz(),.to_poscar(),.to_fdf()\u2026 , then in the save(filepath,filetype=init_filetype,optional: optional: selectivedynamicstag, ). Probably better to o   Errors: if path directory doesn\u2019t exist o   Errors: if other information is not passed \u2022   .to_direct(lattice_matrix=)),.to_positional(lattice_matrix=) o   Convert to positional coordinates. If cartesian molecule, you will need to pass lattice_matrix information either in dictionary form, {\u2018lattice_constant\u2019:1.0,\u2019lattice\u2019:[[2,0,0],[0,2,0],[0,0,2]]} or {constant:1.0,vector_1:[2,0,0],vector_2:[0,2,0],vector_3:[0,0,2]}or in list/tuple form [1.0, [2,0,0],[0,2,0],[0,0,2]] or as the LatticeMatrix object as LatticeMatrix(constant=1.0,vector_1=[2,0,0],vector_2=[0,2,0],vector_3=[0,0,2]). \u2022   .to_cartestian() o   Converts to cartesian coordinates. \u2022   Can have the convert() method which will use the other methods to_cartesian() and to_direct() \u2022   .move(x:float,y:float,z:float) o   Returns object with moved atoms \u2022   .rotate(axis:int | literal[\u2018x\u2019,\u2019y\u2019,\u2019z\u2019], angle: float, units:str = \u2019deg\u2019, or \u2018rad\u2019) o   Returns rotated object \u2022    .delete(index, placeholder:bool=False) o   When placeholder is active, it replaces the selected atoms with a placeholder coord CoordType(sp=\u2019Zz\u2019,x=\u2026,y=\u2026,z=\u2026.) o   Returns molecule object with deleted atoms \u2022   .manipulate(index, function:str=\u2019move\u2019 | \u2018rotate\u2019,args,kwargs] o   Would then pass args,**kwargs to the .move()/.rotate() method. o   Have to check if if default arguments are provided, if  TODO \u2022   DONE Add endline argument to format() (to reuse it with print command) \u2022   DONE Create a print method that prints to terminal. Name it print()? \u2022   Figure out selective coords and dynamics \u2022   Add to_cartesian(), to_positional(), to_direct() \u2022   DONE Fix ABCmolecule printout, (need to add vasp specific attributes) \u2022   DONE Figure out a definite way of having positional/cartesian coordinates in abcmolecule \u2022   DONE Ensure every method and function has a doc string. \u2022   Add read_poscar function that is mask for read_vasp function \u2022   Maybe add abcanimation and xyzanimation so that there is a difference between them and it functions will be read_xdatcar() read_xyz_animation() read_vasp_animation(). We could add all other methods but really only need the index setitem() and convert(). \u2022   Add delete placeholder argument, maybe add a replace option that will replace the place holder with a new atom? \u2022   Maybe add method add_centroid(inplace=False) that adds a centroid coord as a placeholder.  \u2022   Switch over lattice matrix to non dataclass \u2022   Create a determine molecule function, to determine the filetype of the molecule and it would return a reference to the class \u201creturn ABCMolecule\u201d \u2022   Add inplace to delete()</p>"}]}